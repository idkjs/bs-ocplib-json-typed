// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Json_repr = require("./json_repr.bs.js");
var Caml_float = require("bs-platform/lib/js/caml_float.js");
var Json_query = require("./json_query.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

var version = "http://json-schema.org/draft-04/schema#";

function element(kind) {
  return {
          title: undefined,
          description: undefined,
          default: undefined,
          enum: undefined,
          kind: kind,
          format: undefined,
          id: undefined
        };
}

function option_map(f, v) {
  if (v !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(v)));
  }
  
}

function eq_element(a, b) {
  if (Caml_obj.caml_equal(a.title, b.title) && Caml_obj.caml_equal(a.description, b.description) && Caml_obj.caml_equal(option_map(Json_repr.from_any, a.default), option_map(Json_repr.from_any, b.default)) && Caml_obj.caml_equal(option_map((function (param) {
                return List.map(Json_repr.from_any, param);
              }), a.enum), option_map((function (param) {
                return List.map(Json_repr.from_any, param);
              }), b.enum)) && eq_kind(a.kind, b.kind) && Caml_obj.caml_equal(a.format, b.format)) {
    return Caml_obj.caml_equal(a.id, b.id);
  } else {
    return false;
  }
}

function eq_kind(a, b) {
  if (typeof a === "number") {
    switch (a) {
      case /* Boolean */0 :
          return b === 0;
      case /* Null */1 :
          return b === 1;
      case /* Any */2 :
          return b === 2;
      case /* Dummy */3 :
          if (typeof b === "number") {
            return b >= 3;
          } else {
            return false;
          }
      
    }
  } else {
    switch (a.TAG | 0) {
      case /* Object */0 :
          if (typeof b === "number" || b.TAG !== /* Object */0) {
            return false;
          } else {
            var a$1 = a._0;
            var b$1 = b._0;
            if (a$1.min_properties !== b$1.min_properties) {
              return false;
            }
            if (!Caml_obj.caml_equal(a$1.max_properties, b$1.max_properties)) {
              return false;
            }
            if (!Caml_obj.caml_equal(List.sort(Caml_obj.caml_compare, a$1.property_dependencies), List.sort(Caml_obj.caml_compare, b$1.property_dependencies))) {
              return false;
            }
            var match = a$1.additional_properties;
            var match$1 = b$1.additional_properties;
            if ((
                match !== undefined ? (
                    match$1 !== undefined ? eq_element(match, match$1) : false
                  ) : match$1 === undefined
              ) && List.length(a$1.pattern_properties) === List.length(b$1.pattern_properties) && List.for_all2((function (param, param$1) {
                      return param[0] === param$1[0] ? eq_element(param[1], param$1[1]) : false;
                    }), List.sort((function (param, param$1) {
                          return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                        }), a$1.pattern_properties), List.sort((function (param, param$1) {
                          return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                        }), b$1.pattern_properties)) && List.length(a$1.schema_dependencies) === List.length(b$1.schema_dependencies) && List.for_all2((function (param, param$1) {
                      return param[0] === param$1[0] ? eq_element(param[1], param$1[1]) : false;
                    }), List.sort((function (param, param$1) {
                          return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                        }), a$1.schema_dependencies), List.sort((function (param, param$1) {
                          return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                        }), b$1.schema_dependencies)) && List.length(a$1.properties) === List.length(b$1.properties)) {
              return List.for_all2((function (param, param$1) {
                            if (param[0] === param$1[0] && eq_element(param[1], param$1[1]) && param[2] === param$1[2]) {
                              return Caml_obj.caml_equal(option_map(Json_repr.from_any, param[3]), option_map(Json_repr.from_any, param$1[3]));
                            } else {
                              return false;
                            }
                          }), List.sort((function (param, param$1) {
                                return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                              }), a$1.properties), List.sort((function (param, param$1) {
                                return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                              }), b$1.properties));
            } else {
              return false;
            }
          }
      case /* Array */1 :
          if (typeof b === "number") {
            return false;
          }
          if (b.TAG !== /* Array */1) {
            return false;
          }
          var esb = b._0;
          var esa = a._0;
          if (List.length(esa) === List.length(esb) && List.for_all2(eq_element, esa, esb)) {
            return eq_array_specs(a._1, b._1);
          } else {
            return false;
          }
      case /* Monomorphic_array */2 :
          if (typeof b === "number" || !(b.TAG === /* Monomorphic_array */2 && eq_element(a._0, b._0))) {
            return false;
          } else {
            return eq_array_specs(a._1, b._1);
          }
      case /* Combine */3 :
          if (typeof b === "number") {
            return false;
          }
          if (b.TAG !== /* Combine */3) {
            return false;
          }
          var esb$1 = b._1;
          var esa$1 = a._1;
          if (a._0 === b._0 && List.length(esa$1) === List.length(esb$1)) {
            return List.for_all2(eq_element, esa$1, esb$1);
          } else {
            return false;
          }
      case /* Def_ref */4 :
          if (typeof b === "number" || b.TAG !== /* Def_ref */4) {
            return false;
          } else {
            return Caml_obj.caml_equal(a._0, b._0);
          }
      case /* Id_ref */5 :
          if (typeof b === "number" || b.TAG !== /* Id_ref */5) {
            return false;
          } else {
            return a._0 === b._0;
          }
      case /* Ext_ref */6 :
          if (typeof b === "number" || b.TAG !== /* Ext_ref */6) {
            return false;
          } else {
            return a._0 === b._0;
          }
      case /* String */7 :
          if (typeof b === "number" || b.TAG !== /* String */7) {
            return false;
          } else {
            return Caml_obj.caml_equal(a._0, b._0);
          }
      case /* Integer */8 :
          if (typeof b === "number" || b.TAG !== /* Integer */8) {
            return false;
          } else {
            return Caml_obj.caml_equal(a._0, b._0);
          }
      case /* Number */9 :
          if (typeof b === "number" || b.TAG !== /* Number */9) {
            return false;
          } else {
            return Caml_obj.caml_equal(a._0, b._0);
          }
      
    }
  }
}

function eq_array_specs(a, b) {
  if (a.min_items !== b.min_items) {
    return false;
  }
  if (!Caml_obj.caml_equal(a.max_items, b.max_items)) {
    return false;
  }
  if (a.unique_items !== b.unique_items) {
    return false;
  }
  var match = a.additional_items;
  var match$1 = b.additional_items;
  if (match !== undefined) {
    if (match$1 !== undefined) {
      return eq_element(match, match$1);
    } else {
      return false;
    }
  } else {
    return match$1 === undefined;
  }
}

function pp_string(ppf, s) {
  return Json_repr.pp(undefined, undefined, Json_repr.Ezjsonm, ppf, {
              NAME: "String",
              VAL: s
            });
}

function pp_num(ppf, m) {
  if (Math.abs(m) < 1000) {
    return Curry._1(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* Float */8,
                      _0: /* Float_g */9,
                      _1: /* No_padding */0,
                      _2: /* No_precision */0,
                      _3: /* End_of_format */0
                    },
                    _1: "%g"
                  }), m);
  }
  var match = m < 0 ? [
      false,
      -m
    ] : [
      true,
      m
    ];
  var m$1 = match[1];
  var pos = match[0];
  if (List.fold_left((function (acc, d) {
            if (acc) {
              return acc;
            }
            var v = Math.log(m$1 + d) / Math.log(2);
            return Math.abs(Math.ceil(v) - v) < 0.00001 ? (Curry._2(Format.fprintf(ppf, /* Format */{
                                _0: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "2^",
                                    _1: {
                                      TAG: /* Float */8,
                                      _0: /* Float_g */9,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: /* End_of_format */0
                                    }
                                  }
                                },
                                _1: "%s2^%g"
                              }), pos ? "" : "-", v), pos && d < 0 || !pos && d > 0 ? Curry._1(Format.fprintf(ppf, /* Format */{
                                  _0: {
                                    TAG: /* Char_literal */12,
                                    _0: /* '+' */43,
                                    _1: {
                                      TAG: /* Float */8,
                                      _0: /* Float_g */9,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: /* End_of_format */0
                                    }
                                  },
                                  _1: "+%g"
                                }), Math.abs(d)) : undefined, pos && d > 0 || !pos && d < 0 ? Curry._1(Format.fprintf(ppf, /* Format */{
                                  _0: {
                                    TAG: /* Char_literal */12,
                                    _0: /* '-' */45,
                                    _1: {
                                      TAG: /* Float */8,
                                      _0: /* Float_g */9,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: /* End_of_format */0
                                    }
                                  },
                                  _1: "-%g"
                                }), Math.abs(d)) : undefined, true) : false;
          }), false, {
          hd: -2,
          tl: {
            hd: -1,
            tl: {
              hd: 0,
              tl: {
                hd: 1,
                tl: {
                  hd: 2,
                  tl: /* [] */0
                }
              }
            }
          }
        })) {
    return ;
  } else {
    return Curry._1(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* Float */8,
                      _0: /* Float_f */0,
                      _1: /* No_padding */0,
                      _2: /* No_precision */0,
                      _3: /* End_of_format */0
                    },
                    _1: "%f"
                  }), m$1);
  }
}

function pp_numeric_specs(ppf, param) {
  var maximum = param.maximum;
  var minimum = param.minimum;
  var multiple_of = param.multiple_of;
  return Curry._6(Format.fprintf(ppf, /* Format */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: {
                      TAG: /* Alpha */15,
                      _0: {
                        TAG: /* Alpha */15,
                        _0: /* End_of_format */0
                      }
                    }
                  },
                  _1: "%a%a%a"
                }), (function (ppf, v) {
                if (v !== undefined) {
                  return Curry._1(Format.fprintf(ppf, /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "multiple of ",
                                    _1: {
                                      TAG: /* Float */8,
                                      _0: /* Float_g */9,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: /* End_of_format */0
                                    }
                                  },
                                  _1: "multiple of %g"
                                }), v);
                }
                
              }), multiple_of, (function (ppf, param) {
                if (param[0] !== undefined && (param[1] !== undefined || param[2] !== undefined)) {
                  return Format.fprintf(ppf, /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: ", ",
                                _1: /* End_of_format */0
                              },
                              _1: ", "
                            });
                }
                
              }), [
              multiple_of,
              minimum,
              maximum
            ], (function (ppf, param) {
                var minimum = param[0];
                if (minimum === undefined && param[1] === undefined) {
                  return ;
                }
                return Curry._4(Format.fprintf(ppf, /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "\xe2\x88\x88 ",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: ", ",
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: /* End_of_format */0
                                      }
                                    }
                                  }
                                },
                                _1: "\xe2\x88\x88 %a, %a"
                              }), (function (ppf, param) {
                              if (param === undefined) {
                                return Format.fprintf(ppf, /* Format */{
                                            _0: {
                                              TAG: /* String_literal */11,
                                              _0: "]\xe2\x88\x9e",
                                              _1: /* End_of_format */0
                                            },
                                            _1: "]\xe2\x88\x9e"
                                          });
                              }
                              var m = param[0];
                              if (param[1] === "Inclusive") {
                                return Curry._2(Format.fprintf(ppf, /* Format */{
                                                _0: {
                                                  TAG: /* Char_literal */12,
                                                  _0: /* '[' */91,
                                                  _1: {
                                                    TAG: /* Alpha */15,
                                                    _0: /* End_of_format */0
                                                  }
                                                },
                                                _1: "[%a"
                                              }), pp_num, m);
                              } else {
                                return Curry._2(Format.fprintf(ppf, /* Format */{
                                                _0: {
                                                  TAG: /* Char_literal */12,
                                                  _0: /* ']' */93,
                                                  _1: {
                                                    TAG: /* Alpha */15,
                                                    _0: /* End_of_format */0
                                                  }
                                                },
                                                _1: "]%a"
                                              }), pp_num, m);
                              }
                            }), minimum, (function (ppf, param) {
                              if (param === undefined) {
                                return Format.fprintf(ppf, /* Format */{
                                            _0: {
                                              TAG: /* String_literal */11,
                                              _0: "\xe2\x88\x9e[",
                                              _1: /* End_of_format */0
                                            },
                                            _1: "\xe2\x88\x9e["
                                          });
                              }
                              var m = param[0];
                              if (param[1] === "Inclusive") {
                                return Curry._2(Format.fprintf(ppf, /* Format */{
                                                _0: {
                                                  TAG: /* Alpha */15,
                                                  _0: {
                                                    TAG: /* Char_literal */12,
                                                    _0: /* ']' */93,
                                                    _1: /* End_of_format */0
                                                  }
                                                },
                                                _1: "%a]"
                                              }), pp_num, m);
                              } else {
                                return Curry._2(Format.fprintf(ppf, /* Format */{
                                                _0: {
                                                  TAG: /* Alpha */15,
                                                  _0: {
                                                    TAG: /* Char_literal */12,
                                                    _0: /* '[' */91,
                                                    _1: /* End_of_format */0
                                                  }
                                                },
                                                _1: "%a["
                                              }), pp_num, m);
                              }
                            }), param[1]);
              }), [
              minimum,
              maximum
            ]);
}

function pp_path(ppf, path) {
  if (!path) {
    return Json_query.print_path_as_json_path(true, ppf, path);
  }
  var match = path.hd;
  if (typeof match === "string") {
    return Json_query.print_path_as_json_path(true, ppf, path);
  }
  if (match.NAME !== "Field") {
    return Json_query.print_path_as_json_path(true, ppf, path);
  }
  if (match.VAL !== "definitions") {
    return Json_query.print_path_as_json_path(true, ppf, path);
  }
  var match$1 = path.tl;
  if (!match$1) {
    return Json_query.print_path_as_json_path(true, ppf, path);
  }
  var match$2 = match$1.hd;
  if (typeof match$2 === "string" || !(match$2.NAME === "Field" && !match$1.tl)) {
    return Json_query.print_path_as_json_path(true, ppf, path);
  } else {
    return Curry._1(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: /* End_of_format */0
                    },
                    _1: "%s"
                  }), match$2.VAL);
  }
}

function pp_desc(element) {
  var text;
  var title = element.title;
  if (title !== undefined) {
    var description = element.description;
    if (description !== undefined) {
      return (function (ppf, param) {
                return Curry._4(Format.fprintf(ppf, /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "/* ",
                                  _1: {
                                    TAG: /* Formatting_gen */18,
                                    _0: {
                                      TAG: /* Open_box */1,
                                      _0: /* Format */{
                                        _0: {
                                          TAG: /* String_literal */11,
                                          _0: "<v 0>",
                                          _1: /* End_of_format */0
                                        },
                                        _1: "<v 0>"
                                      }
                                    },
                                    _1: {
                                      TAG: /* Formatting_gen */18,
                                      _0: {
                                        TAG: /* Open_box */1,
                                        _0: /* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "<hov 0>",
                                            _1: /* End_of_format */0
                                          },
                                          _1: "<hov 0>"
                                        }
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@,",
                                              _1: 0,
                                              _2: 0
                                            },
                                            _1: {
                                              TAG: /* Formatting_gen */18,
                                              _0: {
                                                TAG: /* Open_box */1,
                                                _0: /* Format */{
                                                  _0: {
                                                    TAG: /* String_literal */11,
                                                    _0: "<hov 0>",
                                                    _1: /* End_of_format */0
                                                  },
                                                  _1: "<hov 0>"
                                                }
                                              },
                                              _1: {
                                                TAG: /* Alpha */15,
                                                _0: {
                                                  TAG: /* Formatting_lit */17,
                                                  _0: /* Close_box */0,
                                                  _1: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: /* Close_box */0,
                                                    _1: {
                                                      TAG: /* String_literal */11,
                                                      _0: " */",
                                                      _1: /* End_of_format */0
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                _1: "/* @[<v 0>@[<hov 0>%a@]@,@[<hov 0>%a@]@] */"
                              }), Format.pp_print_text, title, Format.pp_print_text, description);
              });
    }
    text = title;
  } else {
    var text$1 = element.description;
    if (text$1 === undefined) {
      return ;
    }
    text = text$1;
  }
  return (function (ppf, param) {
            return Curry._2(Format.fprintf(ppf, /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "/* ",
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<hov 0>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<hov 0>"
                                  }
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: " */",
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            },
                            _1: "/* @[<hov 0>%a@] */"
                          }), Format.pp_print_text, text);
          });
}

function pp_element(ppf, element) {
  var id = element.id;
  if (id !== undefined) {
    return Curry._1(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* Char_literal */12,
                      _0: /* '#' */35,
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "#%s"
                  }), id);
  }
  var format = element.format;
  if (format !== undefined) {
    return Curry._1(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: /* End_of_format */0
                    },
                    _1: "%s"
                  }), format);
  }
  var cases = element.enum;
  if (cases !== undefined) {
    var pp_sep = function (ppf, param) {
      return Format.fprintf(ppf, /* Format */{
                  _0: {
                    TAG: /* Formatting_lit */17,
                    _0: {
                      TAG: /* Break */0,
                      _0: "@ ",
                      _1: 1,
                      _2: 0
                    },
                    _1: {
                      TAG: /* String_literal */11,
                      _0: "| ",
                      _1: /* End_of_format */0
                    }
                  },
                  _1: "@ | "
                });
    };
    var partial_arg = false;
    var partial_arg$1 = function (param, param$1) {
      return Json_repr.pp_any(partial_arg, undefined, undefined, param, param$1);
    };
    var partial_arg$2 = pp_sep;
    return Curry._2(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<hv 0>",
                            _1: /* End_of_format */0
                          },
                          _1: "<hv 0>"
                        }
                      },
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_box */0,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "@[<hv 0>%a@]"
                  }), (function (param, param$1) {
                  return Format.pp_print_list(partial_arg$2, partial_arg$1, param, param$1);
                }), cases);
  }
  var pp_desc$1 = pp_desc(element);
  if (pp_desc$1 !== undefined) {
    var stripped_default = element.default;
    var stripped_enum = element.enum;
    var stripped_kind = element.kind;
    var stripped_format = element.format;
    var stripped_id = element.id;
    var stripped = {
      title: undefined,
      description: undefined,
      default: stripped_default,
      enum: stripped_enum,
      kind: stripped_kind,
      format: stripped_format,
      id: stripped_id
    };
    var specs = element.kind;
    if (typeof specs !== "number") {
      switch (specs.TAG | 0) {
        case /* Object */0 :
            return Curry._4(Format.fprintf(ppf, /* Format */{
                            _0: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "<v 2>",
                                    _1: /* End_of_format */0
                                  },
                                  _1: "<v 2>"
                                }
                              },
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "{ ",
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@,",
                                      _1: 0,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* Alpha */15,
                                      _0: {
                                        TAG: /* String_literal */11,
                                        _0: " }",
                                        _1: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@[<v 2>{ %a@,%a }@]"
                          }), pp_desc$1, undefined, pp_object_contents, specs._0);
        case /* Combine */3 :
            return Curry._4(Format.fprintf(ppf, /* Format */{
                            _0: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@,",
                                  _1: 0,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: /* End_of_format */0
                                }
                              }
                            },
                            _1: "%a@,%a"
                          }), pp_desc$1, undefined, pp_element, stripped);
        default:
          
      }
    }
    return Curry._4(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* Alpha */15,
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: {
                          TAG: /* Alpha */15,
                          _0: /* End_of_format */0
                        }
                      }
                    },
                    _1: "%a@ %a"
                  }), pp_element, stripped, pp_desc$1, undefined);
  }
  var specs$1 = element.kind;
  if (typeof specs$1 === "number") {
    switch (specs$1) {
      case /* Boolean */0 :
          return Format.fprintf(ppf, /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "boolean",
                        _1: /* End_of_format */0
                      },
                      _1: "boolean"
                    });
      case /* Null */1 :
          return Format.fprintf(ppf, /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "null",
                        _1: /* End_of_format */0
                      },
                      _1: "null"
                    });
      case /* Any */2 :
          return Format.fprintf(ppf, /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "any",
                        _1: /* End_of_format */0
                      },
                      _1: "any"
                    });
      case /* Dummy */3 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "json_schema.ml",
                  304,
                  23
                ],
                Error: new Error()
              };
      
    }
  } else {
    switch (specs$1.TAG | 0) {
      case /* Object */0 :
          var specs$2 = specs$1._0;
          if (!specs$2.properties && !specs$2.pattern_properties && specs$2.additional_properties === undefined && specs$2.min_properties === 0) {
            var match = specs$2.max_properties;
            if (match !== undefined && match === 0 && !specs$2.schema_dependencies && !specs$2.property_dependencies) {
              return Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "{}",
                            _1: /* End_of_format */0
                          },
                          _1: "{}"
                        });
            }
            
          }
          return Curry._2(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<v 2>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<v 2>"
                              }
                            },
                            _1: {
                              TAG: /* String_literal */11,
                              _0: "{ ",
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " }",
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          },
                          _1: "@[<v 2>{ %a }@]"
                        }), pp_object_contents, specs$2);
      case /* Array */1 :
          var match$1 = specs$1._1;
          var match$2 = match$1.max_items;
          if (match$2 === 0) {
            return Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "[]",
                          _1: /* End_of_format */0
                        },
                        _1: "[]"
                      });
          }
          var additional_items = match$1.additional_items;
          var first = {
            contents: true
          };
          var pp_sep$1 = function (ppf, param) {
            if (first.contents) {
              first.contents = false;
              return ;
            } else {
              return Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* ',' */44,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: /* End_of_format */0
                            }
                          },
                          _1: ",@ "
                        });
            }
          };
          Format.fprintf(ppf, /* Format */{
                _0: {
                  TAG: /* Formatting_gen */18,
                  _0: {
                    TAG: /* Open_box */1,
                    _0: /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "<hv 2>",
                        _1: /* End_of_format */0
                      },
                      _1: "<hv 2>"
                    }
                  },
                  _1: {
                    TAG: /* String_literal */11,
                    _0: "[ ",
                    _1: /* End_of_format */0
                  }
                },
                _1: "@[<hv 2>[ "
              });
          List.iter((function (elt) {
                  return Curry._4(Format.fprintf(ppf, /* Format */{
                                  _0: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Alpha */15,
                                      _0: /* End_of_format */0
                                    }
                                  },
                                  _1: "%a%a"
                                }), pp_sep$1, undefined, pp_element, elt);
                }), specs$1._0);
          if (additional_items !== undefined) {
            if (additional_items.kind === 2) {
              Curry._2(Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* ',' */44,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "...",
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "%a,@ ..."
                      }), pp_sep$1, undefined);
            } else {
              Curry._4(Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* Alpha */15,
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* ',' */44,
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " ...",
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        },
                        _1: "%a,@ %a ..."
                      }), pp_sep$1, undefined, pp_element, additional_items);
            }
          }
          return Format.fprintf(ppf, /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: " ]",
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Close_box */0,
                          _1: /* End_of_format */0
                        }
                      },
                      _1: " ]@]"
                    });
      case /* Monomorphic_array */2 :
          var match$3 = specs$1._1;
          var match$4 = match$3.max_items;
          var elt = specs$1._0;
          if (match$4 === 0) {
            return Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "[]",
                          _1: /* End_of_format */0
                        },
                        _1: "[]"
                      });
          }
          var add_elt = match$3.additional_items;
          if (add_elt !== undefined) {
            if (add_elt.kind === 2) {
              return Curry._2(Format.fprintf(ppf, /* Format */{
                              _0: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<hv 2>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<hv 2>"
                                  }
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "[ ",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: " ...,",
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* String_literal */11,
                                          _0: "... ]",
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              _1: "@[<hv 2>[ %a ...,@ ... ]@]"
                            }), pp_element, elt);
            } else {
              return Curry._4(Format.fprintf(ppf, /* Format */{
                              _0: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<hv 2>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<hv 2>"
                                  }
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "[ ",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: " ...,",
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Alpha */15,
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: " ... ]",
                                            _1: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              _1: "@[<hv 2>[ %a ...,@ %a ... ]@]"
                            }), pp_element, elt, pp_element, add_elt);
            }
          } else {
            return Curry._2(Format.fprintf(ppf, /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "[ ",
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " ... ]",
                                  _1: /* End_of_format */0
                                }
                              }
                            },
                            _1: "[ %a ... ]"
                          }), pp_element, elt);
          }
      case /* Combine */3 :
          var c = specs$1._0;
          if (c >= 3) {
            var match$5 = specs$1._1;
            if (match$5 && !match$5.tl) {
              return Curry._2(Format.fprintf(ppf, /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "! ",
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: /* End_of_format */0
                                }
                              },
                              _1: "! %a"
                            }), pp_element, match$5.hd);
            }
            
          }
          var pp_sep$2 = function (ppf, param) {
            switch (c) {
              case /* Any_of */0 :
                  return Format.fprintf(ppf, /* Format */{
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "| ",
                                  _1: /* End_of_format */0
                                }
                              },
                              _1: "@ | "
                            });
              case /* One_of */1 :
                  return Format.fprintf(ppf, /* Format */{
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "|| ",
                                  _1: /* End_of_format */0
                                }
                              },
                              _1: "@ || "
                            });
              case /* All_of */2 :
                  return Format.fprintf(ppf, /* Format */{
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: "&& ",
                                  _1: /* End_of_format */0
                                }
                              },
                              _1: "@ && "
                            });
              case /* Not */3 :
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "json_schema.ml",
                          312,
                          23
                        ],
                        Error: new Error()
                      };
              
            }
          };
          var partial_arg$3 = pp_sep$2;
          return Curry._2(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Formatting_gen */18,
                            _0: {
                              TAG: /* Open_box */1,
                              _0: /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "<hv 0>",
                                  _1: /* End_of_format */0
                                },
                                _1: "<hv 0>"
                              }
                            },
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Close_box */0,
                                _1: /* End_of_format */0
                              }
                            }
                          },
                          _1: "@[<hv 0>%a@]"
                        }), (function (param, param$1) {
                        return Format.pp_print_list(partial_arg$3, pp_element, param, param$1);
                      }), specs$1._1);
      case /* Def_ref */4 :
          return Curry._2(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '$' */36,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: /* End_of_format */0
                            }
                          },
                          _1: "$%a"
                        }), pp_path, specs$1._0);
      case /* Id_ref */5 :
          return Curry._1(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Char_literal */12,
                            _0: /* '#' */35,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "#%s"
                        }), specs$1._0);
      case /* Ext_ref */6 :
          return Curry._1(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          },
                          _1: "%s"
                        }), specs$1._0);
      case /* String */7 :
          var match$6 = specs$1._0;
          var pat = match$6.pattern;
          if (pat !== undefined) {
            if (match$6.min_length === 0 && match$6.max_length === undefined) {
              return Curry._1(Format.fprintf(ppf, /* Format */{
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* '/' */47,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* '/' */47,
                                    _1: /* End_of_format */0
                                  }
                                }
                              },
                              _1: "/%s/"
                            }), pat);
            }
            
          } else if (match$6.min_length === 0 && match$6.max_length === undefined) {
            return Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "string",
                          _1: /* End_of_format */0
                        },
                        _1: "string"
                      });
          }
          return Curry._6(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* String_literal */11,
                              _0: " (",
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "length",
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ')' */41,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "%a (%alength%a)"
                        }), (function (ppf, pat) {
                        if (pat !== undefined) {
                          return Curry._1(Format.fprintf(ppf, /* Format */{
                                          _0: {
                                            TAG: /* Char_literal */12,
                                            _0: /* '/' */47,
                                            _1: {
                                              TAG: /* String */2,
                                              _0: /* No_padding */0,
                                              _1: {
                                                TAG: /* Char_literal */12,
                                                _0: /* '/' */47,
                                                _1: /* End_of_format */0
                                              }
                                            }
                                          },
                                          _1: "/%s/"
                                        }), pat);
                        } else {
                          return Format.fprintf(ppf, /* Format */{
                                      _0: {
                                        TAG: /* String_literal */11,
                                        _0: "string",
                                        _1: /* End_of_format */0
                                      },
                                      _1: "string"
                                    });
                        }
                      }), pat, (function (ppf, n) {
                        if (n > 0) {
                          return Curry._1(Format.fprintf(ppf, /* Format */{
                                          _0: {
                                            TAG: /* Int */4,
                                            _0: /* Int_d */0,
                                            _1: /* No_padding */0,
                                            _2: /* No_precision */0,
                                            _3: {
                                              TAG: /* String_literal */11,
                                              _0: " <= ",
                                              _1: /* End_of_format */0
                                            }
                                          },
                                          _1: "%d <= "
                                        }), n);
                        }
                        
                      }), match$6.min_length, (function (ppf, m) {
                        if (m !== undefined) {
                          return Curry._1(Format.fprintf(ppf, /* Format */{
                                          _0: {
                                            TAG: /* String_literal */11,
                                            _0: "<= ",
                                            _1: {
                                              TAG: /* Int */4,
                                              _0: /* Int_d */0,
                                              _1: /* No_padding */0,
                                              _2: /* No_precision */0,
                                              _3: /* End_of_format */0
                                            }
                                          },
                                          _1: "<= %d"
                                        }), m);
                        }
                        
                      }), match$6.max_length);
      case /* Integer */8 :
          var specs$3 = specs$1._0;
          if (specs$3.multiple_of === undefined && specs$3.minimum === undefined && specs$3.maximum === undefined) {
            return Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "integer",
                          _1: /* End_of_format */0
                        },
                        _1: "integer"
                      });
          }
          return Curry._2(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "integer ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: /* End_of_format */0
                            }
                          },
                          _1: "integer %a"
                        }), pp_numeric_specs, specs$3);
      case /* Number */9 :
          var specs$4 = specs$1._0;
          if (specs$4.multiple_of === undefined && specs$4.minimum === undefined && specs$4.maximum === undefined) {
            return Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "number",
                          _1: /* End_of_format */0
                        },
                        _1: "number"
                      });
          }
          return Curry._2(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "number ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: /* End_of_format */0
                            }
                          },
                          _1: "number %a"
                        }), pp_numeric_specs, specs$4);
      
    }
  }
}

function pp_object_contents(ppf, param) {
  var additional_properties = param.additional_properties;
  var first = {
    contents: true
  };
  var pp_sep = function (ppf, param) {
    if (first.contents) {
      first.contents = false;
      return ;
    } else {
      return Format.fprintf(ppf, /* Format */{
                  _0: {
                    TAG: /* Char_literal */12,
                    _0: /* ',' */44,
                    _1: {
                      TAG: /* Formatting_lit */17,
                      _0: {
                        TAG: /* Break */0,
                        _0: "@ ",
                        _1: 1,
                        _2: 0
                      },
                      _1: /* End_of_format */0
                    }
                  },
                  _1: ",@ "
                });
    }
  };
  List.iter((function (param) {
          return Curry._7(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "<hv 2>",
                                    _1: /* End_of_format */0
                                  },
                                  _1: "<hv 2>"
                                }
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* ':' */58,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "%a@[<hv 2>%a%s:@ %a@]"
                        }), pp_sep, undefined, pp_string, param[0], param[2] ? "" : "?", pp_element, param[1]);
        }), param.properties);
  List.iter((function (param) {
          return Curry._5(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "<hv 2>",
                                    _1: /* End_of_format */0
                                  },
                                  _1: "<hv 2>"
                                }
                              },
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* '/' */47,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: "/:",
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@ ",
                                        _1: 1,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: /* Close_box */0,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "%a@[<hv 2>/%s/:@ %a@]"
                        }), pp_sep, undefined, param[0], pp_element, param[1]);
        }), param.pattern_properties);
  if (additional_properties !== undefined) {
    if (additional_properties.kind === 2) {
      return Curry._2(Format.fprintf(ppf, /* Format */{
                      _0: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "...",
                          _1: /* End_of_format */0
                        }
                      },
                      _1: "%a..."
                    }), pp_sep, undefined);
    } else {
      return Curry._4(Format.fprintf(ppf, /* Format */{
                      _0: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Formatting_gen */18,
                          _0: {
                            TAG: /* Open_box */1,
                            _0: /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "<hv 2>",
                                _1: /* End_of_format */0
                              },
                              _1: "<hv 2>"
                            }
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "*:",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@ ",
                                _1: 1,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Alpha */15,
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: /* Close_box */0,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "%a@[<hv 2>*:@ %a@]"
                    }), pp_sep, undefined, pp_element, additional_properties);
    }
  }
  
}

function pp(ppf, schema) {
  Format.fprintf(ppf, /* Format */{
        _0: {
          TAG: /* Formatting_gen */18,
          _0: {
            TAG: /* Open_box */1,
            _0: /* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "<v 0>",
                _1: /* End_of_format */0
              },
              _1: "<v 0>"
            }
          },
          _1: /* End_of_format */0
        },
        _1: "@[<v 0>"
      });
  pp_element(ppf, schema.root);
  List.iter((function (param) {
          var elt = param[1];
          var path = param[0];
          var pp_desc$1 = pp_desc(elt);
          if (pp_desc$1 === undefined) {
            return Curry._4(Format.fprintf(ppf, /* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<hv 2>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<hv 2>"
                                  }
                                },
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '$' */36,
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ':' */58,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Alpha */15,
                                          _0: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@,@[<hv 2>$%a:@ %a@]"
                          }), pp_path, path, pp_element, elt);
          }
          var stripped_default = elt.default;
          var stripped_enum = elt.enum;
          var stripped_kind = elt.kind;
          var stripped_format = elt.format;
          var stripped_id = elt.id;
          var stripped = {
            title: undefined,
            description: undefined,
            default: stripped_default,
            enum: stripped_enum,
            kind: stripped_kind,
            format: stripped_format,
            id: stripped_id
          };
          return Curry._6(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@,",
                              _1: 0,
                              _2: 0
                            },
                            _1: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "<v 2>",
                                    _1: /* End_of_format */0
                                  },
                                  _1: "<v 2>"
                                }
                              },
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* '$' */36,
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Char_literal */12,
                                    _0: /* ':' */58,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@,",
                                        _1: 0,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@,",
                                            _1: 0,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@,@[<v 2>$%a:@,%a@,%a@]"
                        }), pp_path, path, pp_desc$1, undefined, pp_element, stripped);
        }), schema.definitions);
  List.iter((function (param) {
          var elt = param[1];
          var id = param[0];
          var pp_desc$1 = pp_desc(elt);
          if (pp_desc$1 === undefined) {
            return Curry._3(Format.fprintf(ppf, /* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* Formatting_gen */18,
                                _0: {
                                  TAG: /* Open_box */1,
                                  _0: /* Format */{
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "<hv 2>",
                                      _1: /* End_of_format */0
                                    },
                                    _1: "<hv 2>"
                                  }
                                },
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '#' */35,
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ':' */58,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@ ",
                                          _1: 1,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* Alpha */15,
                                          _0: {
                                            TAG: /* Formatting_lit */17,
                                            _0: /* Close_box */0,
                                            _1: /* End_of_format */0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "@,@[<hv 2>#%s:@ %a@]"
                          }), id, pp_element, {
                        title: elt.title,
                        description: elt.description,
                        default: elt.default,
                        enum: elt.enum,
                        kind: elt.kind,
                        format: elt.format,
                        id: undefined
                      });
          }
          var stripped_default = elt.default;
          var stripped_enum = elt.enum;
          var stripped_kind = elt.kind;
          var stripped_format = elt.format;
          var stripped = {
            title: undefined,
            description: undefined,
            default: stripped_default,
            enum: stripped_enum,
            kind: stripped_kind,
            format: stripped_format,
            id: undefined
          };
          return Curry._5(Format.fprintf(ppf, /* Format */{
                          _0: {
                            TAG: /* Formatting_lit */17,
                            _0: {
                              TAG: /* Break */0,
                              _0: "@,",
                              _1: 0,
                              _2: 0
                            },
                            _1: {
                              TAG: /* Formatting_gen */18,
                              _0: {
                                TAG: /* Open_box */1,
                                _0: /* Format */{
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "<v 2>",
                                    _1: /* End_of_format */0
                                  },
                                  _1: "<v 2>"
                                }
                              },
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* '#' */35,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* ':' */58,
                                    _1: {
                                      TAG: /* Formatting_lit */17,
                                      _0: {
                                        TAG: /* Break */0,
                                        _0: "@,",
                                        _1: 0,
                                        _2: 0
                                      },
                                      _1: {
                                        TAG: /* Alpha */15,
                                        _0: {
                                          TAG: /* Formatting_lit */17,
                                          _0: {
                                            TAG: /* Break */0,
                                            _0: "@,",
                                            _1: 0,
                                            _2: 0
                                          },
                                          _1: {
                                            TAG: /* Alpha */15,
                                            _0: {
                                              TAG: /* Formatting_lit */17,
                                              _0: /* Close_box */0,
                                              _1: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          _1: "@,@[<v 2>#%s:@,%a@,%a@]"
                        }), id, pp_desc$1, undefined, pp_element, stripped);
        }), schema.ids);
  return Format.fprintf(ppf, /* Format */{
              _0: {
                TAG: /* Formatting_lit */17,
                _0: /* Close_box */0,
                _1: /* End_of_format */0
              },
              _1: "@]"
            });
}

var Cannot_parse = /* @__PURE__ */Caml_exceptions.create("Json_schema.Cannot_parse");

var Dangling_reference = /* @__PURE__ */Caml_exceptions.create("Json_schema.Dangling_reference");

var Bad_reference = /* @__PURE__ */Caml_exceptions.create("Json_schema.Bad_reference");

var Unexpected = /* @__PURE__ */Caml_exceptions.create("Json_schema.Unexpected");

var Duplicate_definition = /* @__PURE__ */Caml_exceptions.create("Json_schema.Duplicate_definition");

function print_error(print_unknown, ppf, uri) {
  if (uri.RE_EXN_ID === Cannot_parse) {
    var partial_arg = true;
    return Curry._4(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<v 2>",
                            _1: /* End_of_format */0
                          },
                          _1: "<v 2>"
                        }
                      },
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "Schema parse error:",
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@,",
                            _1: 0,
                            _2: 0
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "At ",
                            _1: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@,",
                                  _1: 0,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Formatting_lit */17,
                                    _0: /* Close_box */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@[<v 2>Schema parse error:@,At %a@,%a@]"
                  }), (function (param, param$1) {
                  return Json_query.print_path_as_json_path(partial_arg, param, param$1);
                }), uri._1, (function (param, param$1) {
                  return print_error(print_unknown, param, param$1);
                }), uri._2);
  }
  if (uri.RE_EXN_ID === Dangling_reference) {
    return Curry._1(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Dangling reference ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "Dangling reference %s"
                  }), uri._1);
  }
  if (uri.RE_EXN_ID === Bad_reference) {
    return Curry._1(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Illegal reference notation ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "Illegal reference notation %s"
                  }), uri._1);
  }
  if (uri.RE_EXN_ID === Unexpected) {
    return Curry._2(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Unexpected ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: " instead of ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "Unexpected %s instead of %s"
                  }), uri._1, uri._2);
  }
  if (uri.RE_EXN_ID !== Duplicate_definition) {
    return Json_query.print_error(print_unknown, ppf, uri);
  }
  var partial_arg$1 = false;
  return Curry._6(Format.fprintf(ppf, /* Format */{
                  _0: {
                    TAG: /* Formatting_gen */18,
                    _0: {
                      TAG: /* Open_box */1,
                      _0: /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "<v 2>",
                          _1: /* End_of_format */0
                        },
                        _1: "<v 2>"
                      }
                    },
                    _1: {
                      TAG: /* String_literal */11,
                      _0: "Duplicate definition ",
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@,",
                            _1: 0,
                            _2: 0
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "To be inserted:",
                            _1: {
                              TAG: /* Formatting_lit */17,
                              _0: {
                                TAG: /* Break */0,
                                _0: "@,",
                                _1: 0,
                                _2: 0
                              },
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "  ",
                                _1: {
                                  TAG: /* Formatting_gen */18,
                                  _0: {
                                    TAG: /* Open_box */1,
                                    _0: /* Format */{
                                      _0: {
                                        TAG: /* String_literal */11,
                                        _0: "<v 0>",
                                        _1: /* End_of_format */0
                                      },
                                      _1: "<v 0>"
                                    }
                                  },
                                  _1: {
                                    TAG: /* Alpha */15,
                                    _0: {
                                      TAG: /* Formatting_lit */17,
                                      _0: /* Close_box */0,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: {
                                          TAG: /* Break */0,
                                          _0: "@,",
                                          _1: 0,
                                          _2: 0
                                        },
                                        _1: {
                                          TAG: /* String_literal */11,
                                          _0: "Already present:",
                                          _1: {
                                            TAG: /* Formatting_lit */17,
                                            _0: {
                                              TAG: /* Break */0,
                                              _0: "@,",
                                              _1: 0,
                                              _2: 0
                                            },
                                            _1: {
                                              TAG: /* String_literal */11,
                                              _0: "  ",
                                              _1: {
                                                TAG: /* Formatting_gen */18,
                                                _0: {
                                                  TAG: /* Open_box */1,
                                                  _0: /* Format */{
                                                    _0: {
                                                      TAG: /* String_literal */11,
                                                      _0: "<v 0>",
                                                      _1: /* End_of_format */0
                                                    },
                                                    _1: "<v 0>"
                                                  }
                                                },
                                                _1: {
                                                  TAG: /* Alpha */15,
                                                  _0: {
                                                    TAG: /* Formatting_lit */17,
                                                    _0: /* Close_box */0,
                                                    _1: {
                                                      TAG: /* Formatting_lit */17,
                                                      _0: /* Close_box */0,
                                                      _1: /* End_of_format */0
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "@[<v 2>Duplicate definition %a@,To be inserted:@,  @[<v 0>%a@]@,Already present:@,  @[<v 0>%a@]@]"
                }), (function (param, param$1) {
                return Json_query.print_path_as_json_pointer(partial_arg$1, param, param$1);
              }), uri._1, pp_element, uri._2, pp_element, uri._3);
}

function insert_definition(name, elt, defs) {
  var insert = function (param) {
    if (!param) {
      return {
              hd: [
                name,
                elt
              ],
              tl: /* [] */0
            };
    }
    var def = param.hd;
    var defelt = def[1];
    var match = defelt.kind;
    if (Caml_obj.caml_notequal(def[0], name)) {
      return {
              hd: def,
              tl: insert(param.tl)
            };
    }
    if (typeof match === "number" && match >= 3) {
      return {
              hd: [
                name,
                elt
              ],
              tl: param.tl
            };
    }
    if (!eq_element(elt, defelt)) {
      throw {
            RE_EXN_ID: Duplicate_definition,
            _1: name,
            _2: elt,
            _3: defelt,
            Error: new Error()
          };
    }
    return {
            hd: [
              name,
              elt
            ],
            tl: param.tl
          };
  };
  return insert(defs);
}

var Query = Json_query.Make(Json_repr.Ezjsonm);

function to_json(schema) {
  var set_always = function (f, v) {
    return {
            hd: [
              f,
              Curry._1(Json_repr.Ezjsonm.repr, v)
            ],
            tl: /* [] */0
          };
  };
  var set_if_some = function (f, v, cb) {
    if (v !== undefined) {
      return {
              hd: [
                f,
                Curry._1(Json_repr.Ezjsonm.repr, Curry._1(cb, Caml_option.valFromOption(v)))
              ],
              tl: /* [] */0
            };
    } else {
      return /* [] */0;
    }
  };
  var set_if_cons = function (f, v, cb) {
    if (v) {
      return {
              hd: [
                f,
                Curry._1(Json_repr.Ezjsonm.repr, Curry._1(cb, v))
              ],
              tl: /* [] */0
            };
    } else {
      return /* [] */0;
    }
  };
  var set_if_neq = function (f, v, v$prime, cb) {
    if (Caml_obj.caml_notequal(v, v$prime)) {
      return {
              hd: [
                f,
                Curry._1(Json_repr.Ezjsonm.repr, Curry._1(cb, v))
              ],
              tl: /* [] */0
            };
    } else {
      return /* [] */0;
    }
  };
  var format_element = function (param) {
    var kind = param.kind;
    var tmp;
    if (typeof kind === "number") {
      switch (kind) {
        case /* Boolean */0 :
            tmp = set_always("type", {
                  NAME: "String",
                  VAL: "boolean"
                });
            break;
        case /* Null */1 :
            tmp = set_always("type", {
                  NAME: "String",
                  VAL: "null"
                });
            break;
        case /* Any */2 :
            tmp = /* [] */0;
            break;
        case /* Dummy */3 :
            tmp = Pervasives.invalid_arg("Json_schema.to_json: remaining dummy element");
            break;
        
      }
    } else {
      switch (kind.TAG | 0) {
        case /* Object */0 :
            var specs = kind._0;
            var required = List.fold_left((function (r, param) {
                    if (param[2]) {
                      return {
                              hd: Curry._1(Json_repr.Ezjsonm.repr, {
                                    NAME: "String",
                                    VAL: param[0]
                                  }),
                              tl: r
                            };
                    } else {
                      return r;
                    }
                  }), /* [] */0, specs.properties);
            var properties = List.map((function (param) {
                    var l = format_element(param[1]);
                    return [
                            param[0],
                            Curry._1(Json_repr.Ezjsonm.repr, {
                                  NAME: "O",
                                  VAL: l
                                })
                          ];
                  }), specs.properties);
            tmp = Pervasives.$at(set_always("type", {
                      NAME: "String",
                      VAL: "object"
                    }), Pervasives.$at(set_always("properties", {
                          NAME: "O",
                          VAL: properties
                        }), Pervasives.$at(set_if_cons("required", required, (function (l) {
                                return {
                                        NAME: "A",
                                        VAL: l
                                      };
                              })), Pervasives.$at(set_if_cons("patternProperties", specs.pattern_properties, (function (fs) {
                                    return {
                                            NAME: "O",
                                            VAL: List.map((function (param) {
                                                    var l = format_element(param[1]);
                                                    return [
                                                            param[0],
                                                            Curry._1(Json_repr.Ezjsonm.repr, {
                                                                  NAME: "O",
                                                                  VAL: l
                                                                })
                                                          ];
                                                  }), fs)
                                          };
                                  })), Pervasives.$at(set_if_neq("additionalProperties", specs.additional_properties, {
                                      title: undefined,
                                      description: undefined,
                                      default: undefined,
                                      enum: undefined,
                                      kind: /* Any */2,
                                      format: undefined,
                                      id: undefined
                                    }, (function (elt) {
                                        if (elt !== undefined) {
                                          return {
                                                  NAME: "O",
                                                  VAL: format_element(elt)
                                                };
                                        } else {
                                          return {
                                                  NAME: "Bool",
                                                  VAL: false
                                                };
                                        }
                                      })), Pervasives.$at(set_if_neq("minProperties", specs.min_properties, 0, (function (i) {
                                            return {
                                                    NAME: "Float",
                                                    VAL: i
                                                  };
                                          })), Pervasives.$at(set_if_some("maxProperties", specs.max_properties, (function (i) {
                                                return {
                                                        NAME: "Float",
                                                        VAL: i
                                                      };
                                              })), Pervasives.$at(set_if_cons("schemaDependencies", specs.schema_dependencies, (function (fs) {
                                                    return {
                                                            NAME: "O",
                                                            VAL: List.map((function (param) {
                                                                    var l = format_element(param[1]);
                                                                    return [
                                                                            param[0],
                                                                            Curry._1(Json_repr.Ezjsonm.repr, {
                                                                                  NAME: "O",
                                                                                  VAL: l
                                                                                })
                                                                          ];
                                                                  }), fs)
                                                          };
                                                  })), set_if_cons("propertyDependencies", specs.property_dependencies, (function (fs) {
                                                    var strings = function (ls) {
                                                      return List.map((function (s) {
                                                                    return Curry._1(Json_repr.Ezjsonm.repr, {
                                                                                NAME: "String",
                                                                                VAL: s
                                                                              });
                                                                  }), ls);
                                                    };
                                                    var property_dependencies = List.map((function (param) {
                                                            return [
                                                                    param[0],
                                                                    Curry._1(Json_repr.Ezjsonm.repr, {
                                                                          NAME: "A",
                                                                          VAL: strings(param[1])
                                                                        })
                                                                  ];
                                                          }), fs);
                                                    return {
                                                            NAME: "O",
                                                            VAL: property_dependencies
                                                          };
                                                  }))))))))));
            break;
        case /* Array */1 :
            var specs$1 = kind._1;
            tmp = Pervasives.$at(set_always("type", {
                      NAME: "String",
                      VAL: "array"
                    }), Pervasives.$at(set_always("items", {
                          NAME: "A",
                          VAL: List.map((function (elt) {
                                  var l = format_element(elt);
                                  return Curry._1(Json_repr.Ezjsonm.repr, {
                                              NAME: "O",
                                              VAL: l
                                            });
                                }), kind._0)
                        }), Pervasives.$at(set_if_neq("minItems", specs$1.min_items, 0, (function (i) {
                                return {
                                        NAME: "Float",
                                        VAL: i
                                      };
                              })), Pervasives.$at(set_if_some("maxItems", specs$1.max_items, (function (i) {
                                    return {
                                            NAME: "Float",
                                            VAL: i
                                          };
                                  })), Pervasives.$at(set_if_neq("uniqueItems", specs$1.unique_items, false, (function (b) {
                                        return {
                                                NAME: "Bool",
                                                VAL: b
                                              };
                                      })), set_if_neq("additionalItems", specs$1.additional_items, {
                                      title: undefined,
                                      description: undefined,
                                      default: undefined,
                                      enum: undefined,
                                      kind: /* Any */2,
                                      format: undefined,
                                      id: undefined
                                    }, (function (elt) {
                                        if (elt !== undefined) {
                                          return {
                                                  NAME: "O",
                                                  VAL: format_element(elt)
                                                };
                                        } else {
                                          return {
                                                  NAME: "Bool",
                                                  VAL: false
                                                };
                                        }
                                      })))))));
            break;
        case /* Monomorphic_array */2 :
            var match = kind._1;
            tmp = Pervasives.$at(set_always("type", {
                      NAME: "String",
                      VAL: "array"
                    }), Pervasives.$at(set_always("items", {
                          NAME: "O",
                          VAL: format_element(kind._0)
                        }), Pervasives.$at(set_if_neq("minItems", match.min_items, 0, (function (i) {
                                return {
                                        NAME: "Float",
                                        VAL: i
                                      };
                              })), Pervasives.$at(set_if_some("maxItems", match.max_items, (function (i) {
                                    return {
                                            NAME: "Float",
                                            VAL: i
                                          };
                                  })), set_if_neq("uniqueItems", match.unique_items, false, (function (b) {
                                    return {
                                            NAME: "Bool",
                                            VAL: b
                                          };
                                  }))))));
            break;
        case /* Combine */3 :
            var combinator = function (param) {
              switch (param) {
                case /* Any_of */0 :
                    return "anyOf";
                case /* One_of */1 :
                    return "oneOf";
                case /* All_of */2 :
                    return "allOf";
                case /* Not */3 :
                    return "not";
                
              }
            };
            tmp = set_always(combinator(kind._0), {
                  NAME: "A",
                  VAL: List.map((function (elt) {
                          var l = format_element(elt);
                          return Curry._1(Json_repr.Ezjsonm.repr, {
                                      NAME: "O",
                                      VAL: l
                                    });
                        }), kind._1)
                });
            break;
        case /* Def_ref */4 :
            tmp = set_always("$ref", {
                  NAME: "String",
                  VAL: "#" + Json_query.json_pointer_of_path(undefined, kind._0)
                });
            break;
        case /* Id_ref */5 :
            tmp = set_always("$ref", {
                  NAME: "String",
                  VAL: "#" + kind._0
                });
            break;
        case /* Ext_ref */6 :
            tmp = set_always("$ref", {
                  NAME: "String",
                  VAL: kind._0
                });
            break;
        case /* String */7 :
            var match$1 = kind._0;
            tmp = Pervasives.$at(set_always("type", {
                      NAME: "String",
                      VAL: "string"
                    }), Pervasives.$at(set_if_neq("minLength", match$1.min_length, 0, (function (i) {
                            return {
                                    NAME: "Float",
                                    VAL: i
                                  };
                          })), Pervasives.$at(set_if_some("maxLength", match$1.max_length, (function (i) {
                                return {
                                        NAME: "Float",
                                        VAL: i
                                      };
                              })), set_if_some("pattern", match$1.pattern, (function (s) {
                                return {
                                        NAME: "String",
                                        VAL: s
                                      };
                              })))));
            break;
        case /* Integer */8 :
            var specs$2 = kind._0;
            var match$2 = specs$2.minimum;
            var tmp$1;
            if (match$2 !== undefined) {
              var v = match$2[0];
              tmp$1 = match$2[1] === "Inclusive" ? ({
                    hd: [
                      "minimum",
                      Curry._1(Json_repr.Ezjsonm.repr, {
                            NAME: "Float",
                            VAL: v
                          })
                    ],
                    tl: /* [] */0
                  }) : ({
                    hd: [
                      "minimum",
                      Curry._1(Json_repr.Ezjsonm.repr, {
                            NAME: "Float",
                            VAL: v
                          })
                    ],
                    tl: {
                      hd: [
                        "exclusiveMinimum",
                        Curry._1(Json_repr.Ezjsonm.repr, {
                              NAME: "Bool",
                              VAL: true
                            })
                      ],
                      tl: /* [] */0
                    }
                  });
            } else {
              tmp$1 = /* [] */0;
            }
            var match$3 = specs$2.maximum;
            var tmp$2;
            if (match$3 !== undefined) {
              var v$1 = match$3[0];
              tmp$2 = match$3[1] === "Inclusive" ? ({
                    hd: [
                      "maximum",
                      Curry._1(Json_repr.Ezjsonm.repr, {
                            NAME: "Float",
                            VAL: v$1
                          })
                    ],
                    tl: /* [] */0
                  }) : ({
                    hd: [
                      "maximum",
                      Curry._1(Json_repr.Ezjsonm.repr, {
                            NAME: "Float",
                            VAL: v$1
                          })
                    ],
                    tl: {
                      hd: [
                        "exclusiveMaximum",
                        Curry._1(Json_repr.Ezjsonm.repr, {
                              NAME: "Bool",
                              VAL: true
                            })
                      ],
                      tl: /* [] */0
                    }
                  });
            } else {
              tmp$2 = /* [] */0;
            }
            tmp = Pervasives.$at(set_always("type", {
                      NAME: "String",
                      VAL: "integer"
                    }), Pervasives.$at(set_if_some("multipleOf", specs$2.multiple_of, (function (v) {
                            return {
                                    NAME: "Float",
                                    VAL: v
                                  };
                          })), Pervasives.$at(tmp$1, tmp$2)));
            break;
        case /* Number */9 :
            var specs$3 = kind._0;
            var match$4 = specs$3.minimum;
            var tmp$3;
            if (match$4 !== undefined) {
              var v$2 = match$4[0];
              tmp$3 = match$4[1] === "Inclusive" ? ({
                    hd: [
                      "minimum",
                      Curry._1(Json_repr.Ezjsonm.repr, {
                            NAME: "Float",
                            VAL: v$2
                          })
                    ],
                    tl: /* [] */0
                  }) : ({
                    hd: [
                      "minimum",
                      Curry._1(Json_repr.Ezjsonm.repr, {
                            NAME: "Float",
                            VAL: v$2
                          })
                    ],
                    tl: {
                      hd: [
                        "exclusiveMinimum",
                        Curry._1(Json_repr.Ezjsonm.repr, {
                              NAME: "Bool",
                              VAL: true
                            })
                      ],
                      tl: /* [] */0
                    }
                  });
            } else {
              tmp$3 = /* [] */0;
            }
            var match$5 = specs$3.maximum;
            var tmp$4;
            if (match$5 !== undefined) {
              var v$3 = match$5[0];
              tmp$4 = match$5[1] === "Inclusive" ? ({
                    hd: [
                      "maximum",
                      Curry._1(Json_repr.Ezjsonm.repr, {
                            NAME: "Float",
                            VAL: v$3
                          })
                    ],
                    tl: /* [] */0
                  }) : ({
                    hd: [
                      "maximum",
                      Curry._1(Json_repr.Ezjsonm.repr, {
                            NAME: "Float",
                            VAL: v$3
                          })
                    ],
                    tl: {
                      hd: [
                        "exclusiveMaximum",
                        Curry._1(Json_repr.Ezjsonm.repr, {
                              NAME: "Bool",
                              VAL: true
                            })
                      ],
                      tl: /* [] */0
                    }
                  });
            } else {
              tmp$4 = /* [] */0;
            }
            tmp = Pervasives.$at(set_always("type", {
                      NAME: "String",
                      VAL: "number"
                    }), Pervasives.$at(set_if_some("multipleOf", specs$3.multiple_of, (function (v) {
                            return {
                                    NAME: "Float",
                                    VAL: v
                                  };
                          })), Pervasives.$at(tmp$3, tmp$4)));
            break;
        
      }
    }
    return Pervasives.$at(set_if_some("title", param.title, (function (s) {
                      return {
                              NAME: "String",
                              VAL: s
                            };
                    })), Pervasives.$at(set_if_some("description", param.description, (function (s) {
                          return {
                                  NAME: "String",
                                  VAL: s
                                };
                        })), Pervasives.$at(tmp, Pervasives.$at(set_if_some("default", param.default, (function (j) {
                                  return Curry._1(Json_repr.Ezjsonm.view, Json_repr.any_to_repr(Json_repr.Ezjsonm, j));
                                })), Pervasives.$at(set_if_some("enum", param.enum, (function (js) {
                                      return {
                                              NAME: "A",
                                              VAL: List.map((function (param) {
                                                      return Json_repr.any_to_repr(Json_repr.Ezjsonm, param);
                                                    }), js)
                                            };
                                    })), set_if_some("format", param.format, (function (s) {
                                      return {
                                              NAME: "String",
                                              VAL: s
                                            };
                                    })))))));
  };
  var l = Pervasives.$at(set_always("$schema", {
            NAME: "String",
            VAL: version
          }), format_element(schema.root));
  return List.fold_left((function (acc, param) {
                var l = format_element(param[1]);
                return Curry._3(Query.insert, param[0], Curry._1(Json_repr.Ezjsonm.repr, {
                                NAME: "O",
                                VAL: l
                              }), acc);
              }), Curry._1(Json_repr.Ezjsonm.repr, {
                  NAME: "O",
                  VAL: l
                }), schema.definitions);
}

function unexpected(kind, expected) {
  var kind$1;
  if (typeof kind === "string") {
    kind$1 = "null";
  } else {
    var variant = kind.NAME;
    kind$1 = variant === "A" ? (
        kind.VAL ? "array" : "empty array"
      ) : (
        variant === "O" ? (
            kind.VAL ? "object" : "empty object"
          ) : (
            variant === "Float" ? "number" : (
                variant === "Bool" ? "boolean" : (
                    kind.VAL === "" ? "empty string" : "string"
                  )
              )
          )
      );
  }
  return {
          RE_EXN_ID: Cannot_parse,
          _1: /* [] */0,
          _2: {
            RE_EXN_ID: Unexpected,
            _1: kind$1,
            _2: expected
          }
        };
}

function at_path(p, exn) {
  if (exn.RE_EXN_ID === Cannot_parse) {
    return {
            RE_EXN_ID: Cannot_parse,
            _1: Pervasives.$at(p, exn._1),
            _2: exn._2
          };
  } else {
    return exn;
  }
}

function at_field(n) {
  var partial_arg_0 = {
    NAME: "Field",
    VAL: n
  };
  var partial_arg = {
    hd: partial_arg_0,
    tl: /* [] */0
  };
  return function (param) {
    return at_path(partial_arg, param);
  };
}

function at_index(i) {
  var partial_arg_0 = {
    NAME: "Index",
    VAL: i
  };
  var partial_arg = {
    hd: partial_arg_0,
    tl: /* [] */0
  };
  return function (param) {
    return at_path(partial_arg, param);
  };
}

function of_json(json) {
  var opt_field = function (obj, n) {
    var match = Curry._1(Json_repr.Ezjsonm.view, obj);
    if (typeof match === "string") {
      return ;
    }
    if (match.NAME !== "O") {
      return ;
    }
    try {
      return Caml_option.some(List.assoc(n, match.VAL));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return ;
      }
      throw exn;
    }
  };
  var opt_field_view = function (obj, n) {
    var match = Curry._1(Json_repr.Ezjsonm.view, obj);
    if (typeof match === "string") {
      return ;
    }
    if (match.NAME !== "O") {
      return ;
    }
    try {
      return Curry._1(Json_repr.Ezjsonm.view, List.assoc(n, match.VAL));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return ;
      }
      throw exn;
    }
  };
  var opt_string_field = function (obj, n) {
    var k = opt_field_view(obj, n);
    if (k === undefined) {
      return ;
    }
    if (typeof k === "string") {
      throw at_field(n)(unexpected(k, "string"));
    }
    if (k.NAME === "String") {
      return k.VAL;
    }
    throw at_field(n)(unexpected(k, "string"));
  };
  var opt_bool_field = function (def, obj, n) {
    var k = opt_field_view(obj, n);
    if (k === undefined) {
      return def;
    }
    if (typeof k === "string") {
      throw at_field(n)(unexpected(k, "bool"));
    }
    if (k.NAME === "Bool") {
      return k.VAL;
    }
    throw at_field(n)(unexpected(k, "bool"));
  };
  var opt_int_field = function (obj, n) {
    var k = opt_field_view(obj, n);
    if (k === undefined) {
      return ;
    }
    if (typeof k !== "string" && k.NAME === "Float") {
      var f = k.VAL;
      if (Caml_float.caml_modf_float(f)[0] === 0 && f <= Math.pow(2, 53) && f >= Math.pow(-2, 53)) {
        return f;
      }
      
    }
    throw at_field(n)(unexpected(k, "integer"));
  };
  var opt_length_field = function (obj, n) {
    var k = opt_field_view(obj, n);
    if (k === undefined) {
      return ;
    }
    if (typeof k !== "string" && k.NAME === "Float") {
      var f = k.VAL;
      if (Caml_float.caml_modf_float(f)[0] === 0 && f <= Math.pow(2, 30) && f >= 0) {
        return f | 0;
      }
      
    }
    throw at_field(n)(unexpected(k, "length"));
  };
  var opt_float_field = function (obj, n) {
    var k = opt_field_view(obj, n);
    if (k === undefined) {
      return ;
    }
    if (typeof k === "string") {
      throw at_field(n)(unexpected(k, "number"));
    }
    if (k.NAME === "Float") {
      return k.VAL;
    }
    throw at_field(n)(unexpected(k, "number"));
  };
  var opt_array_field = function (obj, n) {
    var k = opt_field_view(obj, n);
    if (k === undefined) {
      return ;
    }
    if (typeof k === "string") {
      throw at_field(n)(unexpected(k, "array"));
    }
    if (k.NAME === "A") {
      return k.VAL;
    }
    throw at_field(n)(unexpected(k, "array"));
  };
  var opt_uri_field = function (obj, n) {
    var uri = opt_string_field(obj, n);
    if (uri !== undefined) {
      return uri;
    }
    
  };
  var uri = opt_uri_field(json, "id");
  var schema_source = uri !== undefined ? "Uri.with_fragment uri None" : "Uri.empty";
  var collected_definitions = {
    contents: /* [] */0
  };
  var collected_id_defs = {
    contents: /* [] */0
  };
  var collected_id_refs = {
    contents: /* [] */0
  };
  var collect_definition = function (uri) {
    var match = "lol";
    if (match !== undefined) {
      if ($$String.contains(match, /* '/' */47)) {
        var path;
        try {
          path = Json_query.path_of_json_pointer(false, match);
        }
        catch (raw_err){
          var err = Caml_js_exceptions.internalToOCamlException(raw_err);
          throw {
                RE_EXN_ID: Cannot_parse,
                _1: /* [] */0,
                _2: err,
                Error: new Error()
              };
        }
        try {
          var raw = Curry._2(Query.query, path, json);
          if (!List.mem_assoc(path, collected_definitions.contents)) {
            collected_definitions.contents = insert_definition(path, {
                  title: undefined,
                  description: undefined,
                  default: undefined,
                  enum: undefined,
                  kind: /* Dummy */3,
                  format: undefined,
                  id: undefined
                }, collected_definitions.contents);
            var elt;
            try {
              elt = parse_element(schema_source, raw);
            }
            catch (raw_err$1){
              var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
              throw at_path(path, err$1);
            }
            collected_definitions.contents = insert_definition(path, elt, collected_definitions.contents);
          }
          return {
                  TAG: /* Def_ref */4,
                  _0: path
                };
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === "Not_found") {
            throw {
                  RE_EXN_ID: Cannot_parse,
                  _1: /* [] */0,
                  _2: {
                    RE_EXN_ID: Dangling_reference,
                    _1: uri
                  },
                  Error: new Error()
                };
          }
          throw exn;
        }
      } else {
        collected_id_refs.contents = {
          hd: match,
          tl: collected_id_refs.contents
        };
        return {
                TAG: /* Id_ref */5,
                _0: match
              };
      }
    } else {
      throw {
            RE_EXN_ID: Cannot_parse,
            _1: /* [] */0,
            _2: {
              RE_EXN_ID: Bad_reference,
              _1: "uri has no fragment"
            },
            Error: new Error()
          };
    }
  };
  var parse_element = function (source, json) {
    opt_uri_field(json, "id");
    if (source !== schema_source) {
      return {
              title: undefined,
              description: undefined,
              default: undefined,
              enum: undefined,
              kind: {
                TAG: /* Ext_ref */6,
                _0: ""
              },
              format: undefined,
              id: undefined
            };
    }
    var id;
    id = undefined;
    var k = opt_field_view(json, "type");
    var as_kind;
    if (k !== undefined) {
      if (typeof k === "string") {
        var partial_arg_0 = {
          NAME: "Field",
          VAL: "type"
        };
        var partial_arg = {
          hd: partial_arg_0,
          tl: /* [] */0
        };
        throw at_path(partial_arg, unexpected(k, "type, type array or operator"));
      }
      var variant = k.NAME;
      if (variant === "String") {
        as_kind = element(parse_element_kind(source, json, k.VAL));
      } else if (variant === "A") {
        var l = k.VAL;
        if (l) {
          var items = function (_i, _acc, _param) {
            while(true) {
              var param = _param;
              var acc = _acc;
              var i = _i;
              if (param) {
                var k = param.hd;
                if (typeof k !== "string" && k.NAME === "String") {
                  var kind = parse_element_kind(source, json, k.VAL);
                  var $$case = element(kind);
                  _param = param.tl;
                  _acc = {
                    hd: $$case,
                    tl: acc
                  };
                  _i = i + 1 | 0;
                  continue ;
                }
                var partial_arg_0 = {
                  NAME: "Field",
                  VAL: "type"
                };
                var partial_arg = {
                  hd: partial_arg_0,
                  tl: /* [] */0
                };
                throw at_path(partial_arg, at_index(i)(unexpected(k, "type")));
              }
              var kind_1 = List.rev(acc);
              var kind$1 = {
                TAG: /* Combine */3,
                _0: /* Any_of */0,
                _1: kind_1
              };
              return element(kind$1);
            };
          };
          as_kind = items(0, /* [] */0, List.map(Json_repr.Ezjsonm.view, l));
        } else {
          var partial_arg_0$1 = {
            NAME: "Field",
            VAL: "type"
          };
          var partial_arg$1 = {
            hd: partial_arg_0$1,
            tl: /* [] */0
          };
          throw at_path(partial_arg$1, unexpected(k, "type, type array or operator"));
        }
      } else {
        var partial_arg_0$2 = {
          NAME: "Field",
          VAL: "type"
        };
        var partial_arg$2 = {
          hd: partial_arg_0$2,
          tl: /* [] */0
        };
        throw at_path(partial_arg$2, unexpected(k, "type, type array or operator"));
      }
    } else {
      as_kind = undefined;
    }
    var uri = opt_uri_field(json, "$ref");
    var as_ref;
    if (uri !== undefined) {
      var path = collect_definition(uri);
      as_ref = element(path);
    } else {
      as_ref = undefined;
    }
    var as_nary = function (name, combinator, others) {
      var build = function (cases) {
        if (!cases) {
          return ;
        }
        if (!cases.tl) {
          return cases.hd;
        }
        var kind = {
          TAG: /* Combine */3,
          _0: combinator,
          _1: cases
        };
        return element(kind);
      };
      var k = opt_field_view(json, name);
      if (k === undefined) {
        return build(others);
      }
      if (typeof k !== "string" && k.NAME === "A") {
        var cases = k.VAL;
        if (cases) {
          var _i = 0;
          var _acc = /* [] */0;
          var _param = cases;
          while(true) {
            var param = _param;
            var acc = _acc;
            var i = _i;
            if (!param) {
              return build(Pervasives.$at(others, List.rev(acc)));
            }
            var elt;
            try {
              elt = parse_element(source, param.hd);
            }
            catch (raw_err){
              var err = Caml_js_exceptions.internalToOCamlException(raw_err);
              throw at_field(name)(at_index(i)(err));
            }
            _param = param.tl;
            _acc = {
              hd: elt,
              tl: acc
            };
            _i = i + 1 | 0;
            continue ;
          };
        }
        
      }
      throw at_field(name)(unexpected(k, "a list of elements"));
    };
    var elt = opt_field_view(json, "not");
    var as_not;
    if (elt !== undefined) {
      var elt$1;
      try {
        elt$1 = parse_element(source, Curry._1(Json_repr.Ezjsonm.repr, elt));
      }
      catch (raw_err){
        var err = Caml_js_exceptions.internalToOCamlException(raw_err);
        var partial_arg_0$3 = {
          NAME: "Field",
          VAL: "not"
        };
        var partial_arg$3 = {
          hd: partial_arg_0$3,
          tl: /* [] */0
        };
        throw at_path(partial_arg$3, err);
      }
      var kind_1 = {
        hd: elt$1,
        tl: /* [] */0
      };
      var kind = {
        TAG: /* Combine */3,
        _0: /* Not */3,
        _1: kind_1
      };
      as_not = element(kind);
    } else {
      as_not = undefined;
    }
    var title = opt_string_field(json, "title");
    var description = opt_string_field(json, "description");
    var v = opt_field(json, "default");
    var $$default = v !== undefined ? Json_repr.repr_to_any(Json_repr.Ezjsonm, Caml_option.valFromOption(v)) : undefined;
    var v$1 = opt_array_field(json, "enum");
    var $$enum = v$1 !== undefined ? List.map((function (param) {
              return Json_repr.repr_to_any(Json_repr.Ezjsonm, param);
            }), v$1) : undefined;
    var format = opt_string_field(json, "format");
    var as_one_of = as_nary("oneOf", /* One_of */1, /* [] */0);
    var as_any_of = as_nary("anyOf", /* Any_of */0, /* [] */0);
    var all_1 = {
      hd: as_ref,
      tl: {
        hd: as_not,
        tl: {
          hd: as_one_of,
          tl: {
            hd: as_any_of,
            tl: /* [] */0
          }
        }
      }
    };
    var all = {
      hd: as_kind,
      tl: all_1
    };
    var cases = List.flatten(List.map((function (e) {
                if (e !== undefined) {
                  return {
                          hd: e,
                          tl: /* [] */0
                        };
                } else {
                  return /* [] */0;
                }
              }), all));
    var match = as_nary("allOf", /* All_of */2, cases);
    var kind$1 = match !== undefined ? match.kind : /* Any */2;
    return {
            title: title,
            description: description,
            default: $$default,
            enum: $$enum,
            kind: kind$1,
            format: format,
            id: id
          };
  };
  var parse_element_kind = function (source, json, name) {
    var integer_specs = function (json) {
      var multiple_of = opt_int_field(json, "multipleOf");
      var minimum;
      if (opt_bool_field(false, json, "exclusiveMinimum")) {
        var v = opt_int_field(json, "minimum");
        if (v !== undefined) {
          minimum = [
            v,
            "Inclusive"
          ];
        } else {
          throw {
                RE_EXN_ID: "Failure",
                _1: "minimum field required when exclusiveMinimum is true",
                Error: new Error()
              };
        }
      } else {
        var v$1 = opt_int_field(json, "minimum");
        minimum = v$1 !== undefined ? [
            v$1,
            "Exclusive"
          ] : undefined;
      }
      var maximum;
      if (opt_bool_field(false, json, "exclusiveMaximum")) {
        var v$2 = opt_int_field(json, "maximum");
        if (v$2 !== undefined) {
          maximum = [
            v$2,
            "Inclusive"
          ];
        } else {
          throw {
                RE_EXN_ID: "Failure",
                _1: "maximum field required when exclusiveMaximum is true",
                Error: new Error()
              };
        }
      } else {
        var v$3 = opt_int_field(json, "maximum");
        maximum = v$3 !== undefined ? [
            v$3,
            "Exclusive"
          ] : undefined;
      }
      return {
              multiple_of: multiple_of,
              minimum: minimum,
              maximum: maximum
            };
    };
    var numeric_specs = function (json) {
      var multiple_of = opt_float_field(json, "multipleOf");
      var minimum;
      if (opt_bool_field(false, json, "exclusiveMinimum")) {
        var v = opt_float_field(json, "minimum");
        if (v !== undefined) {
          minimum = [
            v,
            "Inclusive"
          ];
        } else {
          throw {
                RE_EXN_ID: "Failure",
                _1: "minimum field required when exclusiveMinimum is true",
                Error: new Error()
              };
        }
      } else {
        var v$1 = opt_float_field(json, "minimum");
        minimum = v$1 !== undefined ? [
            v$1,
            "Exclusive"
          ] : undefined;
      }
      var maximum;
      if (opt_bool_field(false, json, "exclusiveMaximum")) {
        var v$2 = opt_float_field(json, "maximum");
        if (v$2 !== undefined) {
          maximum = [
            v$2,
            "Inclusive"
          ];
        } else {
          throw {
                RE_EXN_ID: "Failure",
                _1: "maximum field required when exclusiveMaximum is true",
                Error: new Error()
              };
        }
      } else {
        var v$3 = opt_float_field(json, "maximum");
        maximum = v$3 !== undefined ? [
            v$3,
            "Exclusive"
          ] : undefined;
      }
      return {
              multiple_of: multiple_of,
              minimum: minimum,
              maximum: maximum
            };
    };
    switch (name) {
      case "array" :
          var unique_items = opt_bool_field(false, json, "uniqueItems");
          var min_items = opt_length_field(json, "minItems");
          var max_items = opt_length_field(json, "maxItems");
          var min_items$1 = min_items !== undefined ? min_items : 0;
          var elt = opt_field_view(json, "additionalItems");
          var specs;
          if (elt !== undefined) {
            var exit = 0;
            if (typeof elt === "string" || elt.NAME !== "Bool") {
              exit = 1;
            } else {
              specs = elt.VAL ? ({
                    min_items: min_items$1,
                    max_items: max_items,
                    unique_items: unique_items,
                    additional_items: {
                      title: undefined,
                      description: undefined,
                      default: undefined,
                      enum: undefined,
                      kind: /* Any */2,
                      format: undefined,
                      id: undefined
                    }
                  }) : ({
                    min_items: min_items$1,
                    max_items: max_items,
                    unique_items: unique_items,
                    additional_items: undefined
                  });
            }
            if (exit === 1) {
              var elt$1;
              try {
                elt$1 = parse_element(source, Curry._1(Json_repr.Ezjsonm.repr, elt));
              }
              catch (raw_err){
                var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                var partial_arg_0 = {
                  NAME: "Field",
                  VAL: "additionalItems"
                };
                var partial_arg = {
                  hd: partial_arg_0,
                  tl: /* [] */0
                };
                throw at_path(partial_arg, err);
              }
              specs = {
                min_items: min_items$1,
                max_items: max_items,
                unique_items: unique_items,
                additional_items: elt$1
              };
            }
            
          } else {
            specs = {
              min_items: min_items$1,
              max_items: max_items,
              unique_items: unique_items,
              additional_items: undefined
            };
          }
          var elt$2 = opt_field_view(json, "items");
          if (elt$2 === undefined) {
            return {
                    TAG: /* Monomorphic_array */2,
                    _0: {
                      title: undefined,
                      description: undefined,
                      default: undefined,
                      enum: undefined,
                      kind: /* Any */2,
                      format: undefined,
                      id: undefined
                    },
                    _1: specs
                  };
          }
          if (typeof elt$2 !== "string" && elt$2.NAME === "A") {
            var _i = 0;
            var _acc = /* [] */0;
            var _param = elt$2.VAL;
            while(true) {
              var param = _param;
              var acc = _acc;
              var i = _i;
              if (!param) {
                return {
                        TAG: /* Array */1,
                        _0: List.rev(acc),
                        _1: specs
                      };
              }
              var elt$3;
              try {
                elt$3 = parse_element(source, param.hd);
              }
              catch (raw_err$1){
                var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
                var partial_arg_0$1 = {
                  NAME: "Field",
                  VAL: "items"
                };
                var partial_arg$1 = {
                  hd: partial_arg_0$1,
                  tl: /* [] */0
                };
                throw at_path(partial_arg$1, at_index(i)(err$1));
              }
              _param = param.tl;
              _acc = {
                hd: elt$3,
                tl: acc
              };
              _i = i + 1 | 0;
              continue ;
            };
          }
          var elt$4;
          try {
            elt$4 = parse_element(source, Curry._1(Json_repr.Ezjsonm.repr, elt$2));
          }
          catch (raw_err$2){
            var err$2 = Caml_js_exceptions.internalToOCamlException(raw_err$2);
            var partial_arg_0$2 = {
              NAME: "Field",
              VAL: "items"
            };
            var partial_arg$2 = {
              hd: partial_arg_0$2,
              tl: /* [] */0
            };
            throw at_path(partial_arg$2, err$2);
          }
          return {
                  TAG: /* Monomorphic_array */2,
                  _0: elt$4,
                  _1: specs
                };
          break;
      case "boolean" :
          return /* Boolean */0;
      case "integer" :
          return {
                  TAG: /* Integer */8,
                  _0: integer_specs(json)
                };
      case "null" :
          return /* Null */1;
      case "number" :
          return {
                  TAG: /* Number */9,
                  _0: numeric_specs(json)
                };
      case "object" :
          var l = opt_array_field(json, "required");
          var required;
          if (l !== undefined) {
            var items = function (_i, _acc, _param) {
              while(true) {
                var param = _param;
                var acc = _acc;
                var i = _i;
                if (!param) {
                  return List.rev(acc);
                }
                var k = param.hd;
                if (typeof k !== "string" && k.NAME === "String") {
                  _param = param.tl;
                  _acc = {
                    hd: k.VAL,
                    tl: acc
                  };
                  _i = i + 1 | 0;
                  continue ;
                }
                var partial_arg_0 = {
                  NAME: "Field",
                  VAL: "required"
                };
                var partial_arg = {
                  hd: partial_arg_0,
                  tl: /* [] */0
                };
                throw at_path(partial_arg, at_index(i)(unexpected(k, "string")));
              };
            };
            required = items(0, /* [] */0, List.map(Json_repr.Ezjsonm.view, l));
          } else {
            required = /* [] */0;
          }
          var k = opt_field_view(json, "properties");
          var properties;
          if (k !== undefined) {
            if (typeof k === "string") {
              var partial_arg_0$3 = {
                NAME: "Field",
                VAL: "properties"
              };
              var partial_arg$3 = {
                hd: partial_arg_0$3,
                tl: /* [] */0
              };
              throw at_path(partial_arg$3, unexpected(k, "object"));
            }
            if (k.NAME === "O") {
              var items$1 = function (_acc, _param) {
                while(true) {
                  var param = _param;
                  var acc = _acc;
                  if (!param) {
                    return List.rev(acc);
                  }
                  var match = param.hd;
                  var n = match[0];
                  var elt;
                  try {
                    elt = parse_element(source, match[1]);
                  }
                  catch (raw_err){
                    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                    var partial_arg_0 = {
                      NAME: "Field",
                      VAL: "properties"
                    };
                    var partial_arg = {
                      hd: partial_arg_0,
                      tl: /* [] */0
                    };
                    throw at_path(partial_arg, at_field(n)(err));
                  }
                  var req = List.mem(n, required);
                  _param = param.tl;
                  _acc = {
                    hd: [
                      n,
                      elt,
                      req,
                      undefined
                    ],
                    tl: acc
                  };
                  continue ;
                };
              };
              properties = items$1(/* [] */0, k.VAL);
            } else {
              var partial_arg_0$4 = {
                NAME: "Field",
                VAL: "properties"
              };
              var partial_arg$4 = {
                hd: partial_arg_0$4,
                tl: /* [] */0
              };
              throw at_path(partial_arg$4, unexpected(k, "object"));
            }
          } else {
            properties = /* [] */0;
          }
          var elt$5 = opt_field_view(json, "additionalProperties");
          var additional_properties;
          if (elt$5 !== undefined) {
            var exit$1 = 0;
            if (typeof elt$5 === "string" || elt$5.NAME !== "Bool") {
              exit$1 = 1;
            } else {
              additional_properties = elt$5.VAL ? ({
                    title: undefined,
                    description: undefined,
                    default: undefined,
                    enum: undefined,
                    kind: /* Any */2,
                    format: undefined,
                    id: undefined
                  }) : undefined;
            }
            if (exit$1 === 1) {
              var tmp;
              try {
                tmp = parse_element(source, Curry._1(Json_repr.Ezjsonm.repr, elt$5));
              }
              catch (raw_err$3){
                var err$3 = Caml_js_exceptions.internalToOCamlException(raw_err$3);
                var partial_arg_0$5 = {
                  NAME: "Field",
                  VAL: "additionalProperties"
                };
                var partial_arg$5 = {
                  hd: partial_arg_0$5,
                  tl: /* [] */0
                };
                throw at_path(partial_arg$5, err$3);
              }
              additional_properties = tmp;
            }
            
          } else {
            additional_properties = {
              title: undefined,
              description: undefined,
              default: undefined,
              enum: undefined,
              kind: /* Any */2,
              format: undefined,
              id: undefined
            };
          }
          var k$1 = opt_field_view(json, "propertyDependencies");
          var property_dependencies;
          if (k$1 !== undefined) {
            if (typeof k$1 === "string") {
              var partial_arg_0$6 = {
                NAME: "Field",
                VAL: "propertyDependencies"
              };
              var partial_arg$6 = {
                hd: partial_arg_0$6,
                tl: /* [] */0
              };
              throw at_path(partial_arg$6, unexpected(k$1, "object"));
            }
            if (k$1.NAME === "O") {
              var sets = function (sacc, param) {
                if (!param) {
                  return List.rev(sacc);
                }
                var match = param.hd;
                var k = match[1];
                var n = match[0];
                if (typeof k !== "string" && k.NAME === "A") {
                  var tl = param.tl;
                  var _j = 0;
                  var _acc = /* [] */0;
                  var _param = List.map(Json_repr.Ezjsonm.view, k.VAL);
                  while(true) {
                    var param$1 = _param;
                    var acc = _acc;
                    var j = _j;
                    if (!param$1) {
                      return sets({
                                  hd: [
                                    n,
                                    List.rev(acc)
                                  ],
                                  tl: sacc
                                }, tl);
                    }
                    var k$1 = param$1.hd;
                    if (typeof k$1 !== "string" && k$1.NAME === "String") {
                      _param = param$1.tl;
                      _acc = {
                        hd: k$1.VAL,
                        tl: acc
                      };
                      _j = j + 1 | 0;
                      continue ;
                    }
                    var partial_arg_0 = {
                      NAME: "Field",
                      VAL: "propertyDependencies"
                    };
                    var partial_arg = {
                      hd: partial_arg_0,
                      tl: /* [] */0
                    };
                    throw at_path(partial_arg, at_field(n)(at_index(j)(unexpected(k$1, "string"))));
                  };
                }
                var partial_arg_0$1 = {
                  NAME: "Field",
                  VAL: "propertyDependencies"
                };
                var partial_arg$1 = {
                  hd: partial_arg_0$1,
                  tl: /* [] */0
                };
                throw at_path(partial_arg$1, at_field(n)(unexpected(k, "string array")));
              };
              property_dependencies = sets(/* [] */0, List.map((function (param) {
                          return [
                                  param[0],
                                  Curry._1(Json_repr.Ezjsonm.view, param[1])
                                ];
                        }), k$1.VAL));
            } else {
              var partial_arg_0$7 = {
                NAME: "Field",
                VAL: "propertyDependencies"
              };
              var partial_arg$7 = {
                hd: partial_arg_0$7,
                tl: /* [] */0
              };
              throw at_path(partial_arg$7, unexpected(k$1, "object"));
            }
          } else {
            property_dependencies = /* [] */0;
          }
          var parse_element_assoc = function (field) {
            var k = opt_field_view(json, field);
            if (k === undefined) {
              return /* [] */0;
            }
            if (typeof k === "string") {
              throw at_field(field)(unexpected(k, "object"));
            }
            if (k.NAME === "O") {
              var _acc = /* [] */0;
              var _param = k.VAL;
              while(true) {
                var param = _param;
                var acc = _acc;
                if (!param) {
                  return List.rev(acc);
                }
                var match = param.hd;
                var n = match[0];
                var elt;
                try {
                  elt = parse_element(source, match[1]);
                }
                catch (raw_err){
                  var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                  throw at_field(field)(at_field(n)(err));
                }
                _param = param.tl;
                _acc = {
                  hd: [
                    n,
                    elt
                  ],
                  tl: acc
                };
                continue ;
              };
            }
            throw at_field(field)(unexpected(k, "object"));
          };
          var pattern_properties = parse_element_assoc("patternProperties");
          var schema_dependencies = parse_element_assoc("schemaDependencies");
          var l$1 = opt_length_field(json, "minProperties");
          var min_properties = l$1 !== undefined ? l$1 : 0;
          var max_properties = opt_length_field(json, "maxProperties");
          return {
                  TAG: /* Object */0,
                  _0: {
                    properties: properties,
                    pattern_properties: pattern_properties,
                    additional_properties: additional_properties,
                    min_properties: min_properties,
                    max_properties: max_properties,
                    schema_dependencies: schema_dependencies,
                    property_dependencies: property_dependencies
                  }
                };
      case "string" :
          var pattern = opt_string_field(json, "pattern");
          var min_length = opt_length_field(json, "minLength");
          var max_length = opt_length_field(json, "maxLength");
          var min_length$1 = min_length !== undefined ? min_length : 0;
          var specs$1 = {
            pattern: pattern,
            min_length: min_length$1,
            max_length: max_length
          };
          return {
                  TAG: /* String */7,
                  _0: specs$1
                };
      default:
        throw {
              RE_EXN_ID: Cannot_parse,
              _1: /* [] */0,
              _2: {
                RE_EXN_ID: Unexpected,
                _1: name,
                _2: "a known type"
              },
              Error: new Error()
            };
    }
  };
  var root = parse_element("Uri.empty", json);
  var exit = 0;
  var val;
  try {
    val = Curry._1(Json_repr.Ezjsonm.view, Curry._2(Query.query, {
              hd: {
                NAME: "Field",
                VAL: "definitions"
              },
              tl: /* [] */0
            }, json));
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID !== "Not_found") {
      throw exn;
    }
    
  }
  if (exit === 1 && typeof val !== "string" && val.NAME === "O") {
    var all = List.map((function (param) {
            return "#/definitions/" + param[0];
          }), val.VAL);
    List.iter((function (uri) {
            collect_definition(uri);
            
          }), all);
  }
  List.iter((function (id) {
          if (List.mem_assoc(id, collected_id_defs.contents)) {
            return ;
          }
          throw {
                RE_EXN_ID: Cannot_parse,
                _1: /* [] */0,
                _2: {
                  RE_EXN_ID: Dangling_reference,
                  _1: "(Uri.(with_fragment empty (Some id)))"
                },
                Error: new Error()
              };
        }), collected_id_refs.contents);
  var ids = collected_id_defs.contents;
  var definitions = collected_definitions.contents;
  return {
          root: root,
          source: schema_source,
          definitions: definitions,
          ids: ids,
          world: /* [] */0
        };
}

function check_definitions(root, definitions) {
  var collected_id_defs = {
    contents: /* [] */0
  };
  var collected_id_refs = {
    contents: /* [] */0
  };
  var check = function (_elt) {
    while(true) {
      var elt = _elt;
      var id = elt.id;
      var kind = elt.kind;
      if (id !== undefined) {
        collected_id_defs.contents = {
          hd: [
            id,
            elt
          ],
          tl: collected_id_defs.contents
        };
      }
      if (typeof kind === "number") {
        return ;
      }
      switch (kind.TAG | 0) {
        case /* Object */0 :
            var match = kind._0;
            var additional_properties = match.additional_properties;
            List.iter((function (param) {
                    return check(param[1]);
                  }), match.properties);
            List.iter((function (param) {
                    return check(param[1]);
                  }), match.pattern_properties);
            List.iter((function (param) {
                    return check(param[1]);
                  }), match.schema_dependencies);
            if (additional_properties === undefined) {
              return ;
            }
            _elt = additional_properties;
            continue ;
        case /* Array */1 :
            var additional_items = kind._1.additional_items;
            List.iter(check, kind._0);
            if (additional_items === undefined) {
              return ;
            }
            _elt = additional_items;
            continue ;
        case /* Monomorphic_array */2 :
            var additional_items$1 = kind._1.additional_items;
            check(kind._0);
            if (additional_items$1 === undefined) {
              return ;
            }
            _elt = additional_items$1;
            continue ;
        case /* Combine */3 :
            return List.iter(check, kind._1);
        case /* Def_ref */4 :
            var path = kind._0;
            if (List.mem_assoc(path, definitions)) {
              return ;
            }
            Json_query.json_pointer_of_path(undefined, path);
            throw {
                  RE_EXN_ID: Dangling_reference,
                  _1: "(Uri.(with_fragment empty) (Some path))",
                  Error: new Error()
                };
        case /* Id_ref */5 :
            collected_id_refs.contents = {
              hd: kind._0,
              tl: collected_id_refs.contents
            };
            return ;
        default:
          return ;
      }
    };
  };
  check(root);
  List.iter((function (param) {
          return check(param[1]);
        }), definitions);
  List.iter((function (id) {
          if (List.mem_assoc(id, collected_id_defs.contents)) {
            return ;
          }
          throw {
                RE_EXN_ID: Dangling_reference,
                _1: "(Uri.(with_fragment empty (Some id)))",
                Error: new Error()
              };
        }), collected_id_refs.contents);
  return collected_id_defs.contents;
}

function create(root) {
  var ids = check_definitions(root, /* [] */0);
  return {
          root: root,
          source: "Uri.empty",
          definitions: /* [] */0,
          ids: ids,
          world: /* [] */0
        };
}

function root(param) {
  return param.root;
}

function update(root, sch) {
  var ids = check_definitions(root, sch.definitions);
  return {
          root: root,
          source: sch.source,
          definitions: sch.definitions,
          ids: ids,
          world: sch.world
        };
}

var any = create({
      title: undefined,
      description: undefined,
      default: undefined,
      enum: undefined,
      kind: /* Any */2,
      format: undefined,
      id: undefined
    });

var self_root = element({
      TAG: /* Ext_ref */6,
      _0: version
    });

var self = {
  root: self_root,
  source: "Uri.empty",
  definitions: /* [] */0,
  ids: /* [] */0,
  world: /* [] */0
};

function simplify(schema) {
  var res = {
    contents: /* [] */0
  };
  var collect = function (_param) {
    while(true) {
      var param = _param;
      var kind = param.kind;
      if (typeof kind === "number") {
        return ;
      }
      switch (kind.TAG | 0) {
        case /* Object */0 :
            var match = kind._0;
            var additional_properties = match.additional_properties;
            List.iter((function (param) {
                    return collect(param[1]);
                  }), match.properties);
            List.iter((function (param) {
                    return collect(param[1]);
                  }), match.pattern_properties);
            List.iter((function (param) {
                    return collect(param[1]);
                  }), match.schema_dependencies);
            if (additional_properties === undefined) {
              return ;
            }
            _param = additional_properties;
            continue ;
        case /* Array */1 :
            var additional_items = kind._1.additional_items;
            List.iter(collect, kind._0);
            if (additional_items === undefined) {
              return ;
            }
            _param = additional_items;
            continue ;
        case /* Monomorphic_array */2 :
            var additional_items$1 = kind._1.additional_items;
            collect(kind._0);
            if (additional_items$1 === undefined) {
              return ;
            }
            _param = additional_items$1;
            continue ;
        case /* Combine */3 :
            return List.iter(collect, kind._1);
        case /* Def_ref */4 :
            var path = kind._0;
            var def = List.assoc(path, schema.definitions);
            res.contents = insert_definition(path, def, res.contents);
            return ;
        default:
          return ;
      }
    };
  };
  collect(schema.root);
  return {
          root: schema.root,
          source: schema.source,
          definitions: res.contents,
          ids: schema.ids,
          world: schema.world
        };
}

function definition_path_of_name(definitions_pathOpt, name) {
  var definitions_path = definitions_pathOpt !== undefined ? definitions_pathOpt : "/definitions/";
  var tmp;
  var exit = 0;
  var val;
  try {
    val = Caml_string.get(name, 0);
    exit = 1;
  }
  catch (exn){
    throw {
          RE_EXN_ID: Bad_reference,
          _1: name,
          Error: new Error()
        };
  }
  if (exit === 1) {
    tmp = val !== 47 ? definitions_path + name : name;
  }
  return Json_query.path_of_json_pointer(false, tmp);
}

function find_definition(definitions_path, name, schema) {
  var path = definition_path_of_name(definitions_path, name);
  return List.assoc(path, schema.definitions);
}

function definition_ref(definitions_path, name) {
  var path = definition_path_of_name(definitions_path, name);
  return element({
              TAG: /* Def_ref */4,
              _0: path
            });
}

function definition_exists(definitions_path, name, schema) {
  var path = definition_path_of_name(definitions_path, name);
  return List.mem_assoc(path, schema.definitions);
}

function add_definition(definitions_path, name, elt, schema) {
  var path = definition_path_of_name(definitions_path, name);
  var definitions = insert_definition(path, elt, schema.definitions);
  return [
          {
            root: schema.root,
            source: schema.source,
            definitions: definitions,
            ids: schema.ids,
            world: schema.world
          },
          element({
                TAG: /* Def_ref */4,
                _0: path
              })
        ];
}

function merge_definitions(param) {
  var sb = param[1];
  var sa = param[0];
  var sorted_merge = function (rem) {
    if (!rem) {
      return rem;
    }
    var match = rem.tl;
    if (!match) {
      return rem;
    }
    var tl = match.tl;
    var b = match.hd;
    var db = b[1];
    var a = rem.hd;
    var da = a[1];
    var na = a[0];
    if (!Caml_obj.caml_equal(na, b[0])) {
      return {
              hd: a,
              tl: sorted_merge({
                    hd: b,
                    tl: tl
                  })
            };
    }
    if (da.kind === /* Dummy */3 || db.kind === /* Dummy */3 || eq_element(da, db)) {
      return {
              hd: [
                na,
                da
              ],
              tl: sorted_merge(tl)
            };
    }
    throw {
          RE_EXN_ID: Duplicate_definition,
          _1: na,
          _2: da,
          _3: db,
          Error: new Error()
        };
  };
  var definitions = sorted_merge(List.sort(Caml_obj.caml_compare, Pervasives.$at(sa.definitions, sb.definitions)));
  return [
          {
            root: sa.root,
            source: sa.source,
            definitions: definitions,
            ids: sa.ids,
            world: sa.world
          },
          {
            root: sb.root,
            source: sb.source,
            definitions: definitions,
            ids: sb.ids,
            world: sb.world
          }
        ];
}

function combine(op, schemas) {
  var _sacc = any;
  var _eacc = /* [] */0;
  var _param = schemas;
  while(true) {
    var param = _param;
    var eacc = _eacc;
    var sacc = _sacc;
    if (!param) {
      return update(element({
                      TAG: /* Combine */3,
                      _0: op,
                      _1: eacc
                    }), sacc);
    }
    var match = merge_definitions([
          sacc,
          param.hd
        ]);
    _param = param.tl;
    _eacc = {
      hd: match[1].root,
      tl: eacc
    };
    _sacc = match[0];
    continue ;
  };
}

function is_nullable(param) {
  var ids = param.ids;
  var definitions = param.definitions;
  var nullable = function (_param) {
    while(true) {
      var param = _param;
      var kind = param.kind;
      if (typeof kind === "number") {
        switch (kind) {
          case /* Null */1 :
          case /* Any */2 :
              return true;
          case /* Dummy */3 :
              break;
          default:
            return false;
        }
      } else {
        switch (kind.TAG | 0) {
          case /* Combine */3 :
              var match = kind._0;
              if (match === 2) {
                return List.for_all(nullable, kind._1);
              }
              if (match < 3) {
                return List.exists(nullable, kind._1);
              }
              var match$1 = kind._1;
              if (match$1 && !match$1.tl) {
                return !nullable(match$1.hd);
              }
              break;
          case /* Def_ref */4 :
              _param = List.assoc(kind._0, definitions);
              continue ;
          case /* Id_ref */5 :
              _param = List.assoc(kind._0, ids);
              continue ;
          default:
            return false;
        }
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "json_schema.ml",
              1179,
              36
            ],
            Error: new Error()
          };
    };
  };
  return nullable(param.root);
}

var object_specs_additional_properties = {
  title: undefined,
  description: undefined,
  default: undefined,
  enum: undefined,
  kind: /* Any */2,
  format: undefined,
  id: undefined
};

var object_specs = {
  properties: /* [] */0,
  pattern_properties: /* [] */0,
  additional_properties: object_specs_additional_properties,
  min_properties: 0,
  max_properties: undefined,
  schema_dependencies: /* [] */0,
  property_dependencies: /* [] */0
};

var array_specs = {
  min_items: 0,
  max_items: undefined,
  unique_items: false,
  additional_items: undefined
};

var string_specs = {
  pattern: undefined,
  min_length: 0,
  max_length: undefined
};

var numeric_specs = {
  multiple_of: undefined,
  minimum: undefined,
  maximum: undefined
};

function Make(funarg) {
  var Query = Json_query.Make(funarg);
  var to_json = function (schema) {
    var set_always = function (f, v) {
      return {
              hd: [
                f,
                Curry._1(funarg.repr, v)
              ],
              tl: /* [] */0
            };
    };
    var set_if_some = function (f, v, cb) {
      if (v !== undefined) {
        return {
                hd: [
                  f,
                  Curry._1(funarg.repr, Curry._1(cb, Caml_option.valFromOption(v)))
                ],
                tl: /* [] */0
              };
      } else {
        return /* [] */0;
      }
    };
    var set_if_cons = function (f, v, cb) {
      if (v) {
        return {
                hd: [
                  f,
                  Curry._1(funarg.repr, Curry._1(cb, v))
                ],
                tl: /* [] */0
              };
      } else {
        return /* [] */0;
      }
    };
    var set_if_neq = function (f, v, v$prime, cb) {
      if (Caml_obj.caml_notequal(v, v$prime)) {
        return {
                hd: [
                  f,
                  Curry._1(funarg.repr, Curry._1(cb, v))
                ],
                tl: /* [] */0
              };
      } else {
        return /* [] */0;
      }
    };
    var format_element = function (param) {
      var kind = param.kind;
      var tmp;
      if (typeof kind === "number") {
        switch (kind) {
          case /* Boolean */0 :
              tmp = set_always("type", {
                    NAME: "String",
                    VAL: "boolean"
                  });
              break;
          case /* Null */1 :
              tmp = set_always("type", {
                    NAME: "String",
                    VAL: "null"
                  });
              break;
          case /* Any */2 :
              tmp = /* [] */0;
              break;
          case /* Dummy */3 :
              tmp = Pervasives.invalid_arg("Json_schema.to_json: remaining dummy element");
              break;
          
        }
      } else {
        switch (kind.TAG | 0) {
          case /* Object */0 :
              var specs = kind._0;
              var required = List.fold_left((function (r, param) {
                      if (param[2]) {
                        return {
                                hd: Curry._1(funarg.repr, {
                                      NAME: "String",
                                      VAL: param[0]
                                    }),
                                tl: r
                              };
                      } else {
                        return r;
                      }
                    }), /* [] */0, specs.properties);
              var properties = List.map((function (param) {
                      var l = format_element(param[1]);
                      return [
                              param[0],
                              Curry._1(funarg.repr, {
                                    NAME: "O",
                                    VAL: l
                                  })
                            ];
                    }), specs.properties);
              tmp = Pervasives.$at(set_always("type", {
                        NAME: "String",
                        VAL: "object"
                      }), Pervasives.$at(set_always("properties", {
                            NAME: "O",
                            VAL: properties
                          }), Pervasives.$at(set_if_cons("required", required, (function (l) {
                                  return {
                                          NAME: "A",
                                          VAL: l
                                        };
                                })), Pervasives.$at(set_if_cons("patternProperties", specs.pattern_properties, (function (fs) {
                                      return {
                                              NAME: "O",
                                              VAL: List.map((function (param) {
                                                      var l = format_element(param[1]);
                                                      return [
                                                              param[0],
                                                              Curry._1(funarg.repr, {
                                                                    NAME: "O",
                                                                    VAL: l
                                                                  })
                                                            ];
                                                    }), fs)
                                            };
                                    })), Pervasives.$at(set_if_neq("additionalProperties", specs.additional_properties, {
                                        title: undefined,
                                        description: undefined,
                                        default: undefined,
                                        enum: undefined,
                                        kind: /* Any */2,
                                        format: undefined,
                                        id: undefined
                                      }, (function (elt) {
                                          if (elt !== undefined) {
                                            return {
                                                    NAME: "O",
                                                    VAL: format_element(elt)
                                                  };
                                          } else {
                                            return {
                                                    NAME: "Bool",
                                                    VAL: false
                                                  };
                                          }
                                        })), Pervasives.$at(set_if_neq("minProperties", specs.min_properties, 0, (function (i) {
                                              return {
                                                      NAME: "Float",
                                                      VAL: i
                                                    };
                                            })), Pervasives.$at(set_if_some("maxProperties", specs.max_properties, (function (i) {
                                                  return {
                                                          NAME: "Float",
                                                          VAL: i
                                                        };
                                                })), Pervasives.$at(set_if_cons("schemaDependencies", specs.schema_dependencies, (function (fs) {
                                                      return {
                                                              NAME: "O",
                                                              VAL: List.map((function (param) {
                                                                      var l = format_element(param[1]);
                                                                      return [
                                                                              param[0],
                                                                              Curry._1(funarg.repr, {
                                                                                    NAME: "O",
                                                                                    VAL: l
                                                                                  })
                                                                            ];
                                                                    }), fs)
                                                            };
                                                    })), set_if_cons("propertyDependencies", specs.property_dependencies, (function (fs) {
                                                      var strings = function (ls) {
                                                        return List.map((function (s) {
                                                                      return Curry._1(funarg.repr, {
                                                                                  NAME: "String",
                                                                                  VAL: s
                                                                                });
                                                                    }), ls);
                                                      };
                                                      var property_dependencies = List.map((function (param) {
                                                              return [
                                                                      param[0],
                                                                      Curry._1(funarg.repr, {
                                                                            NAME: "A",
                                                                            VAL: strings(param[1])
                                                                          })
                                                                    ];
                                                            }), fs);
                                                      return {
                                                              NAME: "O",
                                                              VAL: property_dependencies
                                                            };
                                                    }))))))))));
              break;
          case /* Array */1 :
              var specs$1 = kind._1;
              tmp = Pervasives.$at(set_always("type", {
                        NAME: "String",
                        VAL: "array"
                      }), Pervasives.$at(set_always("items", {
                            NAME: "A",
                            VAL: List.map((function (elt) {
                                    var l = format_element(elt);
                                    return Curry._1(funarg.repr, {
                                                NAME: "O",
                                                VAL: l
                                              });
                                  }), kind._0)
                          }), Pervasives.$at(set_if_neq("minItems", specs$1.min_items, 0, (function (i) {
                                  return {
                                          NAME: "Float",
                                          VAL: i
                                        };
                                })), Pervasives.$at(set_if_some("maxItems", specs$1.max_items, (function (i) {
                                      return {
                                              NAME: "Float",
                                              VAL: i
                                            };
                                    })), Pervasives.$at(set_if_neq("uniqueItems", specs$1.unique_items, false, (function (b) {
                                          return {
                                                  NAME: "Bool",
                                                  VAL: b
                                                };
                                        })), set_if_neq("additionalItems", specs$1.additional_items, {
                                        title: undefined,
                                        description: undefined,
                                        default: undefined,
                                        enum: undefined,
                                        kind: /* Any */2,
                                        format: undefined,
                                        id: undefined
                                      }, (function (elt) {
                                          if (elt !== undefined) {
                                            return {
                                                    NAME: "O",
                                                    VAL: format_element(elt)
                                                  };
                                          } else {
                                            return {
                                                    NAME: "Bool",
                                                    VAL: false
                                                  };
                                          }
                                        })))))));
              break;
          case /* Monomorphic_array */2 :
              var match = kind._1;
              tmp = Pervasives.$at(set_always("type", {
                        NAME: "String",
                        VAL: "array"
                      }), Pervasives.$at(set_always("items", {
                            NAME: "O",
                            VAL: format_element(kind._0)
                          }), Pervasives.$at(set_if_neq("minItems", match.min_items, 0, (function (i) {
                                  return {
                                          NAME: "Float",
                                          VAL: i
                                        };
                                })), Pervasives.$at(set_if_some("maxItems", match.max_items, (function (i) {
                                      return {
                                              NAME: "Float",
                                              VAL: i
                                            };
                                    })), set_if_neq("uniqueItems", match.unique_items, false, (function (b) {
                                      return {
                                              NAME: "Bool",
                                              VAL: b
                                            };
                                    }))))));
              break;
          case /* Combine */3 :
              var combinator = function (param) {
                switch (param) {
                  case /* Any_of */0 :
                      return "anyOf";
                  case /* One_of */1 :
                      return "oneOf";
                  case /* All_of */2 :
                      return "allOf";
                  case /* Not */3 :
                      return "not";
                  
                }
              };
              tmp = set_always(combinator(kind._0), {
                    NAME: "A",
                    VAL: List.map((function (elt) {
                            var l = format_element(elt);
                            return Curry._1(funarg.repr, {
                                        NAME: "O",
                                        VAL: l
                                      });
                          }), kind._1)
                  });
              break;
          case /* Def_ref */4 :
              tmp = set_always("$ref", {
                    NAME: "String",
                    VAL: "#" + Json_query.json_pointer_of_path(undefined, kind._0)
                  });
              break;
          case /* Id_ref */5 :
              tmp = set_always("$ref", {
                    NAME: "String",
                    VAL: "#" + kind._0
                  });
              break;
          case /* Ext_ref */6 :
              tmp = set_always("$ref", {
                    NAME: "String",
                    VAL: kind._0
                  });
              break;
          case /* String */7 :
              var match$1 = kind._0;
              tmp = Pervasives.$at(set_always("type", {
                        NAME: "String",
                        VAL: "string"
                      }), Pervasives.$at(set_if_neq("minLength", match$1.min_length, 0, (function (i) {
                              return {
                                      NAME: "Float",
                                      VAL: i
                                    };
                            })), Pervasives.$at(set_if_some("maxLength", match$1.max_length, (function (i) {
                                  return {
                                          NAME: "Float",
                                          VAL: i
                                        };
                                })), set_if_some("pattern", match$1.pattern, (function (s) {
                                  return {
                                          NAME: "String",
                                          VAL: s
                                        };
                                })))));
              break;
          case /* Integer */8 :
              var specs$2 = kind._0;
              var match$2 = specs$2.minimum;
              var tmp$1;
              if (match$2 !== undefined) {
                var v = match$2[0];
                tmp$1 = match$2[1] === "Inclusive" ? ({
                      hd: [
                        "minimum",
                        Curry._1(funarg.repr, {
                              NAME: "Float",
                              VAL: v
                            })
                      ],
                      tl: /* [] */0
                    }) : ({
                      hd: [
                        "minimum",
                        Curry._1(funarg.repr, {
                              NAME: "Float",
                              VAL: v
                            })
                      ],
                      tl: {
                        hd: [
                          "exclusiveMinimum",
                          Curry._1(funarg.repr, {
                                NAME: "Bool",
                                VAL: true
                              })
                        ],
                        tl: /* [] */0
                      }
                    });
              } else {
                tmp$1 = /* [] */0;
              }
              var match$3 = specs$2.maximum;
              var tmp$2;
              if (match$3 !== undefined) {
                var v$1 = match$3[0];
                tmp$2 = match$3[1] === "Inclusive" ? ({
                      hd: [
                        "maximum",
                        Curry._1(funarg.repr, {
                              NAME: "Float",
                              VAL: v$1
                            })
                      ],
                      tl: /* [] */0
                    }) : ({
                      hd: [
                        "maximum",
                        Curry._1(funarg.repr, {
                              NAME: "Float",
                              VAL: v$1
                            })
                      ],
                      tl: {
                        hd: [
                          "exclusiveMaximum",
                          Curry._1(funarg.repr, {
                                NAME: "Bool",
                                VAL: true
                              })
                        ],
                        tl: /* [] */0
                      }
                    });
              } else {
                tmp$2 = /* [] */0;
              }
              tmp = Pervasives.$at(set_always("type", {
                        NAME: "String",
                        VAL: "integer"
                      }), Pervasives.$at(set_if_some("multipleOf", specs$2.multiple_of, (function (v) {
                              return {
                                      NAME: "Float",
                                      VAL: v
                                    };
                            })), Pervasives.$at(tmp$1, tmp$2)));
              break;
          case /* Number */9 :
              var specs$3 = kind._0;
              var match$4 = specs$3.minimum;
              var tmp$3;
              if (match$4 !== undefined) {
                var v$2 = match$4[0];
                tmp$3 = match$4[1] === "Inclusive" ? ({
                      hd: [
                        "minimum",
                        Curry._1(funarg.repr, {
                              NAME: "Float",
                              VAL: v$2
                            })
                      ],
                      tl: /* [] */0
                    }) : ({
                      hd: [
                        "minimum",
                        Curry._1(funarg.repr, {
                              NAME: "Float",
                              VAL: v$2
                            })
                      ],
                      tl: {
                        hd: [
                          "exclusiveMinimum",
                          Curry._1(funarg.repr, {
                                NAME: "Bool",
                                VAL: true
                              })
                        ],
                        tl: /* [] */0
                      }
                    });
              } else {
                tmp$3 = /* [] */0;
              }
              var match$5 = specs$3.maximum;
              var tmp$4;
              if (match$5 !== undefined) {
                var v$3 = match$5[0];
                tmp$4 = match$5[1] === "Inclusive" ? ({
                      hd: [
                        "maximum",
                        Curry._1(funarg.repr, {
                              NAME: "Float",
                              VAL: v$3
                            })
                      ],
                      tl: /* [] */0
                    }) : ({
                      hd: [
                        "maximum",
                        Curry._1(funarg.repr, {
                              NAME: "Float",
                              VAL: v$3
                            })
                      ],
                      tl: {
                        hd: [
                          "exclusiveMaximum",
                          Curry._1(funarg.repr, {
                                NAME: "Bool",
                                VAL: true
                              })
                        ],
                        tl: /* [] */0
                      }
                    });
              } else {
                tmp$4 = /* [] */0;
              }
              tmp = Pervasives.$at(set_always("type", {
                        NAME: "String",
                        VAL: "number"
                      }), Pervasives.$at(set_if_some("multipleOf", specs$3.multiple_of, (function (v) {
                              return {
                                      NAME: "Float",
                                      VAL: v
                                    };
                            })), Pervasives.$at(tmp$3, tmp$4)));
              break;
          
        }
      }
      return Pervasives.$at(set_if_some("title", param.title, (function (s) {
                        return {
                                NAME: "String",
                                VAL: s
                              };
                      })), Pervasives.$at(set_if_some("description", param.description, (function (s) {
                            return {
                                    NAME: "String",
                                    VAL: s
                                  };
                          })), Pervasives.$at(tmp, Pervasives.$at(set_if_some("default", param.default, (function (j) {
                                    return Curry._1(funarg.view, Json_repr.any_to_repr(funarg, j));
                                  })), Pervasives.$at(set_if_some("enum", param.enum, (function (js) {
                                        return {
                                                NAME: "A",
                                                VAL: List.map((function (param) {
                                                        return Json_repr.any_to_repr(funarg, param);
                                                      }), js)
                                              };
                                      })), set_if_some("format", param.format, (function (s) {
                                        return {
                                                NAME: "String",
                                                VAL: s
                                              };
                                      })))))));
    };
    var l = Pervasives.$at(set_always("$schema", {
              NAME: "String",
              VAL: version
            }), format_element(schema.root));
    return List.fold_left((function (acc, param) {
                  var l = format_element(param[1]);
                  return Curry._3(Query.insert, param[0], Curry._1(funarg.repr, {
                                  NAME: "O",
                                  VAL: l
                                }), acc);
                }), Curry._1(funarg.repr, {
                    NAME: "O",
                    VAL: l
                  }), schema.definitions);
  };
  var unexpected = function (kind, expected) {
    var kind$1;
    if (typeof kind === "string") {
      kind$1 = "null";
    } else {
      var variant = kind.NAME;
      kind$1 = variant === "A" ? (
          kind.VAL ? "array" : "empty array"
        ) : (
          variant === "O" ? (
              kind.VAL ? "object" : "empty object"
            ) : (
              variant === "Float" ? "number" : (
                  variant === "Bool" ? "boolean" : (
                      kind.VAL === "" ? "empty string" : "string"
                    )
                )
            )
        );
    }
    return {
            RE_EXN_ID: Cannot_parse,
            _1: /* [] */0,
            _2: {
              RE_EXN_ID: Unexpected,
              _1: kind$1,
              _2: expected
            }
          };
  };
  var at_path = function (p, exn) {
    if (exn.RE_EXN_ID === Cannot_parse) {
      return {
              RE_EXN_ID: Cannot_parse,
              _1: Pervasives.$at(p, exn._1),
              _2: exn._2
            };
    } else {
      return exn;
    }
  };
  var at_field = function (n) {
    var partial_arg_0 = {
      NAME: "Field",
      VAL: n
    };
    var partial_arg = {
      hd: partial_arg_0,
      tl: /* [] */0
    };
    return function (param) {
      return at_path(partial_arg, param);
    };
  };
  var at_index = function (i) {
    var partial_arg_0 = {
      NAME: "Index",
      VAL: i
    };
    var partial_arg = {
      hd: partial_arg_0,
      tl: /* [] */0
    };
    return function (param) {
      return at_path(partial_arg, param);
    };
  };
  var of_json = function (json) {
    var opt_field = function (obj, n) {
      var match = Curry._1(funarg.view, obj);
      if (typeof match === "string") {
        return ;
      }
      if (match.NAME !== "O") {
        return ;
      }
      try {
        return Caml_option.some(List.assoc(n, match.VAL));
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return ;
        }
        throw exn;
      }
    };
    var opt_field_view = function (obj, n) {
      var match = Curry._1(funarg.view, obj);
      if (typeof match === "string") {
        return ;
      }
      if (match.NAME !== "O") {
        return ;
      }
      try {
        return Curry._1(funarg.view, List.assoc(n, match.VAL));
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return ;
        }
        throw exn;
      }
    };
    var opt_string_field = function (obj, n) {
      var k = opt_field_view(obj, n);
      if (k === undefined) {
        return ;
      }
      if (typeof k === "string") {
        throw at_field(n)(unexpected(k, "string"));
      }
      if (k.NAME === "String") {
        return k.VAL;
      }
      throw at_field(n)(unexpected(k, "string"));
    };
    var opt_bool_field = function (def, obj, n) {
      var k = opt_field_view(obj, n);
      if (k === undefined) {
        return def;
      }
      if (typeof k === "string") {
        throw at_field(n)(unexpected(k, "bool"));
      }
      if (k.NAME === "Bool") {
        return k.VAL;
      }
      throw at_field(n)(unexpected(k, "bool"));
    };
    var opt_int_field = function (obj, n) {
      var k = opt_field_view(obj, n);
      if (k === undefined) {
        return ;
      }
      if (typeof k !== "string" && k.NAME === "Float") {
        var f = k.VAL;
        if (Caml_float.caml_modf_float(f)[0] === 0 && f <= Math.pow(2, 53) && f >= Math.pow(-2, 53)) {
          return f;
        }
        
      }
      throw at_field(n)(unexpected(k, "integer"));
    };
    var opt_length_field = function (obj, n) {
      var k = opt_field_view(obj, n);
      if (k === undefined) {
        return ;
      }
      if (typeof k !== "string" && k.NAME === "Float") {
        var f = k.VAL;
        if (Caml_float.caml_modf_float(f)[0] === 0 && f <= Math.pow(2, 30) && f >= 0) {
          return f | 0;
        }
        
      }
      throw at_field(n)(unexpected(k, "length"));
    };
    var opt_float_field = function (obj, n) {
      var k = opt_field_view(obj, n);
      if (k === undefined) {
        return ;
      }
      if (typeof k === "string") {
        throw at_field(n)(unexpected(k, "number"));
      }
      if (k.NAME === "Float") {
        return k.VAL;
      }
      throw at_field(n)(unexpected(k, "number"));
    };
    var opt_array_field = function (obj, n) {
      var k = opt_field_view(obj, n);
      if (k === undefined) {
        return ;
      }
      if (typeof k === "string") {
        throw at_field(n)(unexpected(k, "array"));
      }
      if (k.NAME === "A") {
        return k.VAL;
      }
      throw at_field(n)(unexpected(k, "array"));
    };
    var opt_uri_field = function (obj, n) {
      var uri = opt_string_field(obj, n);
      if (uri !== undefined) {
        return uri;
      }
      
    };
    var uri = opt_uri_field(json, "id");
    var schema_source = uri !== undefined ? "Uri.with_fragment uri None" : "Uri.empty";
    var collected_definitions = {
      contents: /* [] */0
    };
    var collected_id_defs = {
      contents: /* [] */0
    };
    var collected_id_refs = {
      contents: /* [] */0
    };
    var collect_definition = function (uri) {
      var match = "lol";
      if (match !== undefined) {
        if ($$String.contains(match, /* '/' */47)) {
          var path;
          try {
            path = Json_query.path_of_json_pointer(false, match);
          }
          catch (raw_err){
            var err = Caml_js_exceptions.internalToOCamlException(raw_err);
            throw {
                  RE_EXN_ID: Cannot_parse,
                  _1: /* [] */0,
                  _2: err,
                  Error: new Error()
                };
          }
          try {
            var raw = Curry._2(Query.query, path, json);
            if (!List.mem_assoc(path, collected_definitions.contents)) {
              collected_definitions.contents = insert_definition(path, {
                    title: undefined,
                    description: undefined,
                    default: undefined,
                    enum: undefined,
                    kind: /* Dummy */3,
                    format: undefined,
                    id: undefined
                  }, collected_definitions.contents);
              var elt;
              try {
                elt = parse_element(schema_source, raw);
              }
              catch (raw_err$1){
                var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
                throw at_path(path, err$1);
              }
              collected_definitions.contents = insert_definition(path, elt, collected_definitions.contents);
            }
            return {
                    TAG: /* Def_ref */4,
                    _0: path
                  };
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "Not_found") {
              throw {
                    RE_EXN_ID: Cannot_parse,
                    _1: /* [] */0,
                    _2: {
                      RE_EXN_ID: Dangling_reference,
                      _1: uri
                    },
                    Error: new Error()
                  };
            }
            throw exn;
          }
        } else {
          collected_id_refs.contents = {
            hd: match,
            tl: collected_id_refs.contents
          };
          return {
                  TAG: /* Id_ref */5,
                  _0: match
                };
        }
      } else {
        throw {
              RE_EXN_ID: Cannot_parse,
              _1: /* [] */0,
              _2: {
                RE_EXN_ID: Bad_reference,
                _1: "uri has no fragment"
              },
              Error: new Error()
            };
      }
    };
    var parse_element = function (source, json) {
      opt_uri_field(json, "id");
      if (source !== schema_source) {
        return {
                title: undefined,
                description: undefined,
                default: undefined,
                enum: undefined,
                kind: {
                  TAG: /* Ext_ref */6,
                  _0: ""
                },
                format: undefined,
                id: undefined
              };
      }
      var id;
      id = undefined;
      var k = opt_field_view(json, "type");
      var as_kind;
      if (k !== undefined) {
        if (typeof k === "string") {
          var partial_arg_0 = {
            NAME: "Field",
            VAL: "type"
          };
          var partial_arg = {
            hd: partial_arg_0,
            tl: /* [] */0
          };
          throw at_path(partial_arg, unexpected(k, "type, type array or operator"));
        }
        var variant = k.NAME;
        if (variant === "String") {
          as_kind = element(parse_element_kind(source, json, k.VAL));
        } else if (variant === "A") {
          var l = k.VAL;
          if (l) {
            var items = function (_i, _acc, _param) {
              while(true) {
                var param = _param;
                var acc = _acc;
                var i = _i;
                if (param) {
                  var k = param.hd;
                  if (typeof k !== "string" && k.NAME === "String") {
                    var kind = parse_element_kind(source, json, k.VAL);
                    var $$case = element(kind);
                    _param = param.tl;
                    _acc = {
                      hd: $$case,
                      tl: acc
                    };
                    _i = i + 1 | 0;
                    continue ;
                  }
                  var partial_arg_0 = {
                    NAME: "Field",
                    VAL: "type"
                  };
                  var partial_arg = {
                    hd: partial_arg_0,
                    tl: /* [] */0
                  };
                  throw at_path(partial_arg, at_index(i)(unexpected(k, "type")));
                }
                var kind_1 = List.rev(acc);
                var kind$1 = {
                  TAG: /* Combine */3,
                  _0: /* Any_of */0,
                  _1: kind_1
                };
                return element(kind$1);
              };
            };
            as_kind = items(0, /* [] */0, List.map(funarg.view, l));
          } else {
            var partial_arg_0$1 = {
              NAME: "Field",
              VAL: "type"
            };
            var partial_arg$1 = {
              hd: partial_arg_0$1,
              tl: /* [] */0
            };
            throw at_path(partial_arg$1, unexpected(k, "type, type array or operator"));
          }
        } else {
          var partial_arg_0$2 = {
            NAME: "Field",
            VAL: "type"
          };
          var partial_arg$2 = {
            hd: partial_arg_0$2,
            tl: /* [] */0
          };
          throw at_path(partial_arg$2, unexpected(k, "type, type array or operator"));
        }
      } else {
        as_kind = undefined;
      }
      var uri = opt_uri_field(json, "$ref");
      var as_ref;
      if (uri !== undefined) {
        var path = collect_definition(uri);
        as_ref = element(path);
      } else {
        as_ref = undefined;
      }
      var as_nary = function (name, combinator, others) {
        var build = function (cases) {
          if (!cases) {
            return ;
          }
          if (!cases.tl) {
            return cases.hd;
          }
          var kind = {
            TAG: /* Combine */3,
            _0: combinator,
            _1: cases
          };
          return element(kind);
        };
        var k = opt_field_view(json, name);
        if (k === undefined) {
          return build(others);
        }
        if (typeof k !== "string" && k.NAME === "A") {
          var cases = k.VAL;
          if (cases) {
            var _i = 0;
            var _acc = /* [] */0;
            var _param = cases;
            while(true) {
              var param = _param;
              var acc = _acc;
              var i = _i;
              if (!param) {
                return build(Pervasives.$at(others, List.rev(acc)));
              }
              var elt;
              try {
                elt = parse_element(source, param.hd);
              }
              catch (raw_err){
                var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                throw at_field(name)(at_index(i)(err));
              }
              _param = param.tl;
              _acc = {
                hd: elt,
                tl: acc
              };
              _i = i + 1 | 0;
              continue ;
            };
          }
          
        }
        throw at_field(name)(unexpected(k, "a list of elements"));
      };
      var elt = opt_field_view(json, "not");
      var as_not;
      if (elt !== undefined) {
        var elt$1;
        try {
          elt$1 = parse_element(source, Curry._1(funarg.repr, elt));
        }
        catch (raw_err){
          var err = Caml_js_exceptions.internalToOCamlException(raw_err);
          var partial_arg_0$3 = {
            NAME: "Field",
            VAL: "not"
          };
          var partial_arg$3 = {
            hd: partial_arg_0$3,
            tl: /* [] */0
          };
          throw at_path(partial_arg$3, err);
        }
        var kind_1 = {
          hd: elt$1,
          tl: /* [] */0
        };
        var kind = {
          TAG: /* Combine */3,
          _0: /* Not */3,
          _1: kind_1
        };
        as_not = element(kind);
      } else {
        as_not = undefined;
      }
      var title = opt_string_field(json, "title");
      var description = opt_string_field(json, "description");
      var v = opt_field(json, "default");
      var $$default = v !== undefined ? Json_repr.repr_to_any(funarg, Caml_option.valFromOption(v)) : undefined;
      var v$1 = opt_array_field(json, "enum");
      var $$enum = v$1 !== undefined ? List.map((function (param) {
                return Json_repr.repr_to_any(funarg, param);
              }), v$1) : undefined;
      var format = opt_string_field(json, "format");
      var as_one_of = as_nary("oneOf", /* One_of */1, /* [] */0);
      var as_any_of = as_nary("anyOf", /* Any_of */0, /* [] */0);
      var all_1 = {
        hd: as_ref,
        tl: {
          hd: as_not,
          tl: {
            hd: as_one_of,
            tl: {
              hd: as_any_of,
              tl: /* [] */0
            }
          }
        }
      };
      var all = {
        hd: as_kind,
        tl: all_1
      };
      var cases = List.flatten(List.map((function (e) {
                  if (e !== undefined) {
                    return {
                            hd: e,
                            tl: /* [] */0
                          };
                  } else {
                    return /* [] */0;
                  }
                }), all));
      var match = as_nary("allOf", /* All_of */2, cases);
      var kind$1 = match !== undefined ? match.kind : /* Any */2;
      return {
              title: title,
              description: description,
              default: $$default,
              enum: $$enum,
              kind: kind$1,
              format: format,
              id: id
            };
    };
    var parse_element_kind = function (source, json, name) {
      var integer_specs = function (json) {
        var multiple_of = opt_int_field(json, "multipleOf");
        var minimum;
        if (opt_bool_field(false, json, "exclusiveMinimum")) {
          var v = opt_int_field(json, "minimum");
          if (v !== undefined) {
            minimum = [
              v,
              "Inclusive"
            ];
          } else {
            throw {
                  RE_EXN_ID: "Failure",
                  _1: "minimum field required when exclusiveMinimum is true",
                  Error: new Error()
                };
          }
        } else {
          var v$1 = opt_int_field(json, "minimum");
          minimum = v$1 !== undefined ? [
              v$1,
              "Exclusive"
            ] : undefined;
        }
        var maximum;
        if (opt_bool_field(false, json, "exclusiveMaximum")) {
          var v$2 = opt_int_field(json, "maximum");
          if (v$2 !== undefined) {
            maximum = [
              v$2,
              "Inclusive"
            ];
          } else {
            throw {
                  RE_EXN_ID: "Failure",
                  _1: "maximum field required when exclusiveMaximum is true",
                  Error: new Error()
                };
          }
        } else {
          var v$3 = opt_int_field(json, "maximum");
          maximum = v$3 !== undefined ? [
              v$3,
              "Exclusive"
            ] : undefined;
        }
        return {
                multiple_of: multiple_of,
                minimum: minimum,
                maximum: maximum
              };
      };
      var numeric_specs = function (json) {
        var multiple_of = opt_float_field(json, "multipleOf");
        var minimum;
        if (opt_bool_field(false, json, "exclusiveMinimum")) {
          var v = opt_float_field(json, "minimum");
          if (v !== undefined) {
            minimum = [
              v,
              "Inclusive"
            ];
          } else {
            throw {
                  RE_EXN_ID: "Failure",
                  _1: "minimum field required when exclusiveMinimum is true",
                  Error: new Error()
                };
          }
        } else {
          var v$1 = opt_float_field(json, "minimum");
          minimum = v$1 !== undefined ? [
              v$1,
              "Exclusive"
            ] : undefined;
        }
        var maximum;
        if (opt_bool_field(false, json, "exclusiveMaximum")) {
          var v$2 = opt_float_field(json, "maximum");
          if (v$2 !== undefined) {
            maximum = [
              v$2,
              "Inclusive"
            ];
          } else {
            throw {
                  RE_EXN_ID: "Failure",
                  _1: "maximum field required when exclusiveMaximum is true",
                  Error: new Error()
                };
          }
        } else {
          var v$3 = opt_float_field(json, "maximum");
          maximum = v$3 !== undefined ? [
              v$3,
              "Exclusive"
            ] : undefined;
        }
        return {
                multiple_of: multiple_of,
                minimum: minimum,
                maximum: maximum
              };
      };
      switch (name) {
        case "array" :
            var unique_items = opt_bool_field(false, json, "uniqueItems");
            var min_items = opt_length_field(json, "minItems");
            var max_items = opt_length_field(json, "maxItems");
            var min_items$1 = min_items !== undefined ? min_items : 0;
            var elt = opt_field_view(json, "additionalItems");
            var specs;
            if (elt !== undefined) {
              var exit = 0;
              if (typeof elt === "string" || elt.NAME !== "Bool") {
                exit = 1;
              } else {
                specs = elt.VAL ? ({
                      min_items: min_items$1,
                      max_items: max_items,
                      unique_items: unique_items,
                      additional_items: {
                        title: undefined,
                        description: undefined,
                        default: undefined,
                        enum: undefined,
                        kind: /* Any */2,
                        format: undefined,
                        id: undefined
                      }
                    }) : ({
                      min_items: min_items$1,
                      max_items: max_items,
                      unique_items: unique_items,
                      additional_items: undefined
                    });
              }
              if (exit === 1) {
                var elt$1;
                try {
                  elt$1 = parse_element(source, Curry._1(funarg.repr, elt));
                }
                catch (raw_err){
                  var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                  var partial_arg_0 = {
                    NAME: "Field",
                    VAL: "additionalItems"
                  };
                  var partial_arg = {
                    hd: partial_arg_0,
                    tl: /* [] */0
                  };
                  throw at_path(partial_arg, err);
                }
                specs = {
                  min_items: min_items$1,
                  max_items: max_items,
                  unique_items: unique_items,
                  additional_items: elt$1
                };
              }
              
            } else {
              specs = {
                min_items: min_items$1,
                max_items: max_items,
                unique_items: unique_items,
                additional_items: undefined
              };
            }
            var elt$2 = opt_field_view(json, "items");
            if (elt$2 === undefined) {
              return {
                      TAG: /* Monomorphic_array */2,
                      _0: {
                        title: undefined,
                        description: undefined,
                        default: undefined,
                        enum: undefined,
                        kind: /* Any */2,
                        format: undefined,
                        id: undefined
                      },
                      _1: specs
                    };
            }
            if (typeof elt$2 !== "string" && elt$2.NAME === "A") {
              var _i = 0;
              var _acc = /* [] */0;
              var _param = elt$2.VAL;
              while(true) {
                var param = _param;
                var acc = _acc;
                var i = _i;
                if (!param) {
                  return {
                          TAG: /* Array */1,
                          _0: List.rev(acc),
                          _1: specs
                        };
                }
                var elt$3;
                try {
                  elt$3 = parse_element(source, param.hd);
                }
                catch (raw_err$1){
                  var err$1 = Caml_js_exceptions.internalToOCamlException(raw_err$1);
                  var partial_arg_0$1 = {
                    NAME: "Field",
                    VAL: "items"
                  };
                  var partial_arg$1 = {
                    hd: partial_arg_0$1,
                    tl: /* [] */0
                  };
                  throw at_path(partial_arg$1, at_index(i)(err$1));
                }
                _param = param.tl;
                _acc = {
                  hd: elt$3,
                  tl: acc
                };
                _i = i + 1 | 0;
                continue ;
              };
            }
            var elt$4;
            try {
              elt$4 = parse_element(source, Curry._1(funarg.repr, elt$2));
            }
            catch (raw_err$2){
              var err$2 = Caml_js_exceptions.internalToOCamlException(raw_err$2);
              var partial_arg_0$2 = {
                NAME: "Field",
                VAL: "items"
              };
              var partial_arg$2 = {
                hd: partial_arg_0$2,
                tl: /* [] */0
              };
              throw at_path(partial_arg$2, err$2);
            }
            return {
                    TAG: /* Monomorphic_array */2,
                    _0: elt$4,
                    _1: specs
                  };
            break;
        case "boolean" :
            return /* Boolean */0;
        case "integer" :
            return {
                    TAG: /* Integer */8,
                    _0: integer_specs(json)
                  };
        case "null" :
            return /* Null */1;
        case "number" :
            return {
                    TAG: /* Number */9,
                    _0: numeric_specs(json)
                  };
        case "object" :
            var l = opt_array_field(json, "required");
            var required;
            if (l !== undefined) {
              var items = function (_i, _acc, _param) {
                while(true) {
                  var param = _param;
                  var acc = _acc;
                  var i = _i;
                  if (!param) {
                    return List.rev(acc);
                  }
                  var k = param.hd;
                  if (typeof k !== "string" && k.NAME === "String") {
                    _param = param.tl;
                    _acc = {
                      hd: k.VAL,
                      tl: acc
                    };
                    _i = i + 1 | 0;
                    continue ;
                  }
                  var partial_arg_0 = {
                    NAME: "Field",
                    VAL: "required"
                  };
                  var partial_arg = {
                    hd: partial_arg_0,
                    tl: /* [] */0
                  };
                  throw at_path(partial_arg, at_index(i)(unexpected(k, "string")));
                };
              };
              required = items(0, /* [] */0, List.map(funarg.view, l));
            } else {
              required = /* [] */0;
            }
            var k = opt_field_view(json, "properties");
            var properties;
            if (k !== undefined) {
              if (typeof k === "string") {
                var partial_arg_0$3 = {
                  NAME: "Field",
                  VAL: "properties"
                };
                var partial_arg$3 = {
                  hd: partial_arg_0$3,
                  tl: /* [] */0
                };
                throw at_path(partial_arg$3, unexpected(k, "object"));
              }
              if (k.NAME === "O") {
                var items$1 = function (_acc, _param) {
                  while(true) {
                    var param = _param;
                    var acc = _acc;
                    if (!param) {
                      return List.rev(acc);
                    }
                    var match = param.hd;
                    var n = match[0];
                    var elt;
                    try {
                      elt = parse_element(source, match[1]);
                    }
                    catch (raw_err){
                      var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                      var partial_arg_0 = {
                        NAME: "Field",
                        VAL: "properties"
                      };
                      var partial_arg = {
                        hd: partial_arg_0,
                        tl: /* [] */0
                      };
                      throw at_path(partial_arg, at_field(n)(err));
                    }
                    var req = List.mem(n, required);
                    _param = param.tl;
                    _acc = {
                      hd: [
                        n,
                        elt,
                        req,
                        undefined
                      ],
                      tl: acc
                    };
                    continue ;
                  };
                };
                properties = items$1(/* [] */0, k.VAL);
              } else {
                var partial_arg_0$4 = {
                  NAME: "Field",
                  VAL: "properties"
                };
                var partial_arg$4 = {
                  hd: partial_arg_0$4,
                  tl: /* [] */0
                };
                throw at_path(partial_arg$4, unexpected(k, "object"));
              }
            } else {
              properties = /* [] */0;
            }
            var elt$5 = opt_field_view(json, "additionalProperties");
            var additional_properties;
            if (elt$5 !== undefined) {
              var exit$1 = 0;
              if (typeof elt$5 === "string" || elt$5.NAME !== "Bool") {
                exit$1 = 1;
              } else {
                additional_properties = elt$5.VAL ? ({
                      title: undefined,
                      description: undefined,
                      default: undefined,
                      enum: undefined,
                      kind: /* Any */2,
                      format: undefined,
                      id: undefined
                    }) : undefined;
              }
              if (exit$1 === 1) {
                var tmp;
                try {
                  tmp = parse_element(source, Curry._1(funarg.repr, elt$5));
                }
                catch (raw_err$3){
                  var err$3 = Caml_js_exceptions.internalToOCamlException(raw_err$3);
                  var partial_arg_0$5 = {
                    NAME: "Field",
                    VAL: "additionalProperties"
                  };
                  var partial_arg$5 = {
                    hd: partial_arg_0$5,
                    tl: /* [] */0
                  };
                  throw at_path(partial_arg$5, err$3);
                }
                additional_properties = tmp;
              }
              
            } else {
              additional_properties = {
                title: undefined,
                description: undefined,
                default: undefined,
                enum: undefined,
                kind: /* Any */2,
                format: undefined,
                id: undefined
              };
            }
            var k$1 = opt_field_view(json, "propertyDependencies");
            var property_dependencies;
            if (k$1 !== undefined) {
              if (typeof k$1 === "string") {
                var partial_arg_0$6 = {
                  NAME: "Field",
                  VAL: "propertyDependencies"
                };
                var partial_arg$6 = {
                  hd: partial_arg_0$6,
                  tl: /* [] */0
                };
                throw at_path(partial_arg$6, unexpected(k$1, "object"));
              }
              if (k$1.NAME === "O") {
                var sets = function (sacc, param) {
                  if (!param) {
                    return List.rev(sacc);
                  }
                  var match = param.hd;
                  var k = match[1];
                  var n = match[0];
                  if (typeof k !== "string" && k.NAME === "A") {
                    var tl = param.tl;
                    var _j = 0;
                    var _acc = /* [] */0;
                    var _param = List.map(funarg.view, k.VAL);
                    while(true) {
                      var param$1 = _param;
                      var acc = _acc;
                      var j = _j;
                      if (!param$1) {
                        return sets({
                                    hd: [
                                      n,
                                      List.rev(acc)
                                    ],
                                    tl: sacc
                                  }, tl);
                      }
                      var k$1 = param$1.hd;
                      if (typeof k$1 !== "string" && k$1.NAME === "String") {
                        _param = param$1.tl;
                        _acc = {
                          hd: k$1.VAL,
                          tl: acc
                        };
                        _j = j + 1 | 0;
                        continue ;
                      }
                      var partial_arg_0 = {
                        NAME: "Field",
                        VAL: "propertyDependencies"
                      };
                      var partial_arg = {
                        hd: partial_arg_0,
                        tl: /* [] */0
                      };
                      throw at_path(partial_arg, at_field(n)(at_index(j)(unexpected(k$1, "string"))));
                    };
                  }
                  var partial_arg_0$1 = {
                    NAME: "Field",
                    VAL: "propertyDependencies"
                  };
                  var partial_arg$1 = {
                    hd: partial_arg_0$1,
                    tl: /* [] */0
                  };
                  throw at_path(partial_arg$1, at_field(n)(unexpected(k, "string array")));
                };
                property_dependencies = sets(/* [] */0, List.map((function (param) {
                            return [
                                    param[0],
                                    Curry._1(funarg.view, param[1])
                                  ];
                          }), k$1.VAL));
              } else {
                var partial_arg_0$7 = {
                  NAME: "Field",
                  VAL: "propertyDependencies"
                };
                var partial_arg$7 = {
                  hd: partial_arg_0$7,
                  tl: /* [] */0
                };
                throw at_path(partial_arg$7, unexpected(k$1, "object"));
              }
            } else {
              property_dependencies = /* [] */0;
            }
            var parse_element_assoc = function (field) {
              var k = opt_field_view(json, field);
              if (k === undefined) {
                return /* [] */0;
              }
              if (typeof k === "string") {
                throw at_field(field)(unexpected(k, "object"));
              }
              if (k.NAME === "O") {
                var _acc = /* [] */0;
                var _param = k.VAL;
                while(true) {
                  var param = _param;
                  var acc = _acc;
                  if (!param) {
                    return List.rev(acc);
                  }
                  var match = param.hd;
                  var n = match[0];
                  var elt;
                  try {
                    elt = parse_element(source, match[1]);
                  }
                  catch (raw_err){
                    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                    throw at_field(field)(at_field(n)(err));
                  }
                  _param = param.tl;
                  _acc = {
                    hd: [
                      n,
                      elt
                    ],
                    tl: acc
                  };
                  continue ;
                };
              }
              throw at_field(field)(unexpected(k, "object"));
            };
            var pattern_properties = parse_element_assoc("patternProperties");
            var schema_dependencies = parse_element_assoc("schemaDependencies");
            var l$1 = opt_length_field(json, "minProperties");
            var min_properties = l$1 !== undefined ? l$1 : 0;
            var max_properties = opt_length_field(json, "maxProperties");
            return {
                    TAG: /* Object */0,
                    _0: {
                      properties: properties,
                      pattern_properties: pattern_properties,
                      additional_properties: additional_properties,
                      min_properties: min_properties,
                      max_properties: max_properties,
                      schema_dependencies: schema_dependencies,
                      property_dependencies: property_dependencies
                    }
                  };
        case "string" :
            var pattern = opt_string_field(json, "pattern");
            var min_length = opt_length_field(json, "minLength");
            var max_length = opt_length_field(json, "maxLength");
            var min_length$1 = min_length !== undefined ? min_length : 0;
            var specs$1 = {
              pattern: pattern,
              min_length: min_length$1,
              max_length: max_length
            };
            return {
                    TAG: /* String */7,
                    _0: specs$1
                  };
        default:
          throw {
                RE_EXN_ID: Cannot_parse,
                _1: /* [] */0,
                _2: {
                  RE_EXN_ID: Unexpected,
                  _1: name,
                  _2: "a known type"
                },
                Error: new Error()
              };
      }
    };
    var root = parse_element("Uri.empty", json);
    var exit = 0;
    var val;
    try {
      val = Curry._1(funarg.view, Curry._2(Query.query, {
                hd: {
                  NAME: "Field",
                  VAL: "definitions"
                },
                tl: /* [] */0
              }, json));
      exit = 1;
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID !== "Not_found") {
        throw exn;
      }
      
    }
    if (exit === 1 && typeof val !== "string" && val.NAME === "O") {
      var all = List.map((function (param) {
              return "#/definitions/" + param[0];
            }), val.VAL);
      List.iter((function (uri) {
              collect_definition(uri);
              
            }), all);
    }
    List.iter((function (id) {
            if (List.mem_assoc(id, collected_id_defs.contents)) {
              return ;
            }
            throw {
                  RE_EXN_ID: Cannot_parse,
                  _1: /* [] */0,
                  _2: {
                    RE_EXN_ID: Dangling_reference,
                    _1: "(Uri.(with_fragment empty (Some id)))"
                  },
                  Error: new Error()
                };
          }), collected_id_refs.contents);
    var ids = collected_id_defs.contents;
    var definitions = collected_definitions.contents;
    return {
            root: root,
            source: schema_source,
            definitions: definitions,
            ids: ids,
            world: /* [] */0
          };
  };
  var check_definitions = function (root, definitions) {
    var collected_id_defs = {
      contents: /* [] */0
    };
    var collected_id_refs = {
      contents: /* [] */0
    };
    var check = function (_elt) {
      while(true) {
        var elt = _elt;
        var id = elt.id;
        var kind = elt.kind;
        if (id !== undefined) {
          collected_id_defs.contents = {
            hd: [
              id,
              elt
            ],
            tl: collected_id_defs.contents
          };
        }
        if (typeof kind === "number") {
          return ;
        }
        switch (kind.TAG | 0) {
          case /* Object */0 :
              var match = kind._0;
              var additional_properties = match.additional_properties;
              List.iter((function (param) {
                      return check(param[1]);
                    }), match.properties);
              List.iter((function (param) {
                      return check(param[1]);
                    }), match.pattern_properties);
              List.iter((function (param) {
                      return check(param[1]);
                    }), match.schema_dependencies);
              if (additional_properties === undefined) {
                return ;
              }
              _elt = additional_properties;
              continue ;
          case /* Array */1 :
              var additional_items = kind._1.additional_items;
              List.iter(check, kind._0);
              if (additional_items === undefined) {
                return ;
              }
              _elt = additional_items;
              continue ;
          case /* Monomorphic_array */2 :
              var additional_items$1 = kind._1.additional_items;
              check(kind._0);
              if (additional_items$1 === undefined) {
                return ;
              }
              _elt = additional_items$1;
              continue ;
          case /* Combine */3 :
              return List.iter(check, kind._1);
          case /* Def_ref */4 :
              var path = kind._0;
              if (List.mem_assoc(path, definitions)) {
                return ;
              }
              Json_query.json_pointer_of_path(undefined, path);
              throw {
                    RE_EXN_ID: Dangling_reference,
                    _1: "(Uri.(with_fragment empty) (Some path))",
                    Error: new Error()
                  };
          case /* Id_ref */5 :
              collected_id_refs.contents = {
                hd: kind._0,
                tl: collected_id_refs.contents
              };
              return ;
          default:
            return ;
        }
      };
    };
    check(root);
    List.iter((function (param) {
            return check(param[1]);
          }), definitions);
    List.iter((function (id) {
            if (List.mem_assoc(id, collected_id_defs.contents)) {
              return ;
            }
            throw {
                  RE_EXN_ID: Dangling_reference,
                  _1: "(Uri.(with_fragment empty (Some id)))",
                  Error: new Error()
                };
          }), collected_id_refs.contents);
    return collected_id_defs.contents;
  };
  var create = function (root) {
    var ids = check_definitions(root, /* [] */0);
    return {
            root: root,
            source: "Uri.empty",
            definitions: /* [] */0,
            ids: ids,
            world: /* [] */0
          };
  };
  create({
        title: undefined,
        description: undefined,
        default: undefined,
        enum: undefined,
        kind: /* Any */2,
        format: undefined,
        id: undefined
      });
  element({
        TAG: /* Ext_ref */6,
        _0: version
      });
  return {
          to_json: to_json,
          of_json: of_json
        };
}

exports.element = element;
exports.create = create;
exports.root = root;
exports.update = update;
exports.self = self;
exports.any = any;
exports.combine = combine;
exports.is_nullable = is_nullable;
exports.merge_definitions = merge_definitions;
exports.simplify = simplify;
exports.add_definition = add_definition;
exports.find_definition = find_definition;
exports.definition_exists = definition_exists;
exports.definition_ref = definition_ref;
exports.array_specs = array_specs;
exports.object_specs = object_specs;
exports.string_specs = string_specs;
exports.numeric_specs = numeric_specs;
exports.to_json = to_json;
exports.of_json = of_json;
exports.pp = pp;
exports.Cannot_parse = Cannot_parse;
exports.Dangling_reference = Dangling_reference;
exports.Bad_reference = Bad_reference;
exports.Unexpected = Unexpected;
exports.Duplicate_definition = Duplicate_definition;
exports.print_error = print_error;
exports.Make = Make;
/* Query Not a pure module */
