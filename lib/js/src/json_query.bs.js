// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Buffer = require("bs-platform/lib/js/buffer.js");
var Format = require("bs-platform/lib/js/format.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Json_repr = require("./json_repr.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

var Illegal_pointer_notation = /* @__PURE__ */Caml_exceptions.create("Json_query.Illegal_pointer_notation");

var Unsupported_path_item = /* @__PURE__ */Caml_exceptions.create("Json_query.Unsupported_path_item");

var Cannot_merge = /* @__PURE__ */Caml_exceptions.create("Json_query.Cannot_merge");

function print_path_as_json_path(wildcardsOpt, ppf, nonempty) {
  var wildcards = wildcardsOpt !== undefined ? wildcardsOpt : true;
  if (!nonempty) {
    return Format.fprintf(ppf, /* Format */{
                _0: {
                  TAG: /* Char_literal */12,
                  _0: /* '/' */47,
                  _1: /* End_of_format */0
                },
                _1: "/"
              });
  }
  var print = function (ppf, param) {
    if (!param) {
      return ;
    }
    var match = param.hd;
    if (typeof match !== "string") {
      if (match.NAME === "Field") {
        return Curry._3(Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* '/' */47,
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: /* End_of_format */0
                            }
                          }
                        },
                        _1: "/%s%a"
                      }), match.VAL, print, param.tl);
      } else {
        return Curry._3(Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* '[' */91,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Char_literal */12,
                              _0: /* ']' */93,
                              _1: {
                                TAG: /* Alpha */15,
                                _0: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "[%d]%a"
                      }), match.VAL, print, param.tl);
      }
    }
    if (match === "Star") {
      if (wildcards) {
        return Curry._2(Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* '*' */42,
                          _1: {
                            TAG: /* Alpha */15,
                            _0: /* End_of_format */0
                          }
                        },
                        _1: "*%a"
                      }), print, param.tl);
      }
      throw {
            RE_EXN_ID: Unsupported_path_item,
            _1: "Star",
            _2: "JSON path w/o wildcards",
            Error: new Error()
          };
    }
    if (wildcards) {
      return Curry._2(Format.fprintf(ppf, /* Format */{
                      _0: {
                        TAG: /* Char_literal */12,
                        _0: /* '-' */45,
                        _1: {
                          TAG: /* Alpha */15,
                          _0: /* End_of_format */0
                        }
                      },
                      _1: "-%a"
                    }), print, param.tl);
    }
    throw {
          RE_EXN_ID: Unsupported_path_item,
          _1: "Star",
          _2: "JSON path w/o wildcards",
          Error: new Error()
        };
  };
  return print(ppf, nonempty);
}

function print_path_as_json_pointer(wildcardsOpt, ppf, nonempty) {
  var wildcards = wildcardsOpt !== undefined ? wildcardsOpt : true;
  if (!nonempty) {
    return Format.fprintf(ppf, /* Format */{
                _0: {
                  TAG: /* Char_literal */12,
                  _0: /* '/' */47,
                  _1: /* End_of_format */0
                },
                _1: "/"
              });
  }
  var print = function (ppf, param) {
    if (!param) {
      return ;
    }
    var match = param.hd;
    if (typeof match !== "string") {
      if (match.NAME === "Field") {
        return Curry._3(Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* '/' */47,
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* Alpha */15,
                              _0: /* End_of_format */0
                            }
                          }
                        },
                        _1: "/%s%a"
                      }), match.VAL, print, param.tl);
      } else {
        return Curry._3(Format.fprintf(ppf, /* Format */{
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* '/' */47,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Alpha */15,
                              _0: /* End_of_format */0
                            }
                          }
                        },
                        _1: "/%d%a"
                      }), match.VAL, print, param.tl);
      }
    }
    if (match === "Star") {
      throw {
            RE_EXN_ID: Unsupported_path_item,
            _1: "Star",
            _2: "JSON pointer",
            Error: new Error()
          };
    }
    if (wildcards) {
      return Curry._2(Format.fprintf(ppf, /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "/-",
                        _1: {
                          TAG: /* Alpha */15,
                          _0: /* End_of_format */0
                        }
                      },
                      _1: "/-%a"
                    }), print, param.tl);
    }
    throw {
          RE_EXN_ID: Unsupported_path_item,
          _1: "Star",
          _2: "JSON pointer w/o wildcards",
          Error: new Error()
        };
  };
  return print(ppf, nonempty);
}

function json_pointer_of_path(wildcards, path) {
  return Curry._2(Format.asprintf(/* Format */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: /* End_of_format */0
                  },
                  _1: "%a"
                }), (function (param, param$1) {
                return print_path_as_json_pointer(wildcards, param, param$1);
              }), path);
}

function path_of_json_pointer(wildcardsOpt, str) {
  var wildcards = wildcardsOpt !== undefined ? wildcardsOpt : true;
  var buf = $$Buffer.create(100);
  var len = str.length;
  var slashes = function (acc, _i) {
    while(true) {
      var i = _i;
      if (i >= len) {
        return List.rev(acc);
      }
      if (Caml_string.get(str, i) !== /* '/' */47) {
        var _i$1 = i;
        while(true) {
          var i$1 = _i$1;
          if (i$1 >= len) {
            return List.rev({
                        hd: interp(undefined),
                        tl: acc
                      });
          }
          var unescaped = Caml_string.get(str, i$1);
          if (unescaped === 47) {
            return slashes({
                        hd: interp(undefined),
                        tl: acc
                      }, i$1);
          }
          if (unescaped !== 126) {
            $$Buffer.add_char(buf, unescaped);
            _i$1 = i$1 + 1 | 0;
            continue ;
          }
          if ((i$1 + 1 | 0) >= len) {
            throw {
                  RE_EXN_ID: Illegal_pointer_notation,
                  _1: str,
                  _2: i$1,
                  _3: "Unterminated escape sequence",
                  Error: new Error()
                };
          }
          var _illegal = Caml_string.get(str, i$1);
          if (_illegal !== 48) {
            if (_illegal !== 49) {
              throw {
                    RE_EXN_ID: Illegal_pointer_notation,
                    _1: str,
                    _2: i$1 + 1 | 0,
                    _3: "Illegal escape character",
                    Error: new Error()
                  };
            }
            $$Buffer.add_char(buf, /* '/' */47);
          } else {
            $$Buffer.add_char(buf, /* '~' */126);
          }
          _i$1 = i$1 + 1 | 0;
          continue ;
        };
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  var interp = function (param) {
    var field = $$Buffer.contents(buf);
    $$Buffer.clear(buf);
    if (field === "-") {
      if (wildcards) {
        return "Next";
      }
      throw {
            RE_EXN_ID: Unsupported_path_item,
            _1: "Next",
            _2: "JSON pointer w/o wildcards",
            Error: new Error()
          };
    }
    try {
      return {
              NAME: "Index",
              VAL: Caml_format.caml_int_of_string(field)
            };
    }
    catch (exn){
      return {
              NAME: "Field",
              VAL: field
            };
    }
  };
  if (len === 0) {
    return /* [] */0;
  }
  if (Caml_string.get(str, 0) !== /* '/' */47) {
    throw {
          RE_EXN_ID: Illegal_pointer_notation,
          _1: str,
          _2: 0,
          _3: "Missing initial slash",
          Error: new Error()
        };
  }
  return slashes(/* [] */0, 1);
}

function path_operator_name(param) {
  if (typeof param === "string") {
    if (param === "Star") {
      return "wildcard";
    } else {
      return "array append";
    }
  } else if (param.NAME === "Field") {
    return "field access";
  } else {
    return "array access";
  }
}

function print_error(print_unknown, ppf, err) {
  if (err.RE_EXN_ID === Illegal_pointer_notation) {
    return Curry._3(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* Formatting_gen */18,
                      _0: {
                        TAG: /* Open_box */1,
                        _0: /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "<v 2>",
                            _1: /* End_of_format */0
                          },
                          _1: "<v 2>"
                        }
                      },
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "Illegal pointer notation",
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: {
                            TAG: /* Break */0,
                            _0: "@,",
                            _1: 0,
                            _2: 0
                          },
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "At character ",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* String_literal */11,
                                _0: " of ",
                                _1: {
                                  TAG: /* Caml_string */3,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* Formatting_lit */17,
                                    _0: {
                                      TAG: /* Break */0,
                                      _0: "@,",
                                      _1: 0,
                                      _2: 0
                                    },
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* Formatting_lit */17,
                                        _0: /* Close_box */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "@[<v 2>Illegal pointer notation@,At character %d of %S@,%s@]"
                  }), err._2, err._1, err._3);
  }
  if (err.RE_EXN_ID === Unsupported_path_item) {
    return Curry._2(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Path operator ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: " unsupported by ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "Path operator %s unsupported by %s"
                  }), path_operator_name(err._1), err._2);
  }
  if (err.RE_EXN_ID !== Cannot_merge) {
    if (print_unknown !== undefined) {
      return Curry._2(print_unknown, ppf, err);
    } else {
      return Curry._1(Format.fprintf(ppf, /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Unhandled error ",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: /* End_of_format */0
                        }
                      },
                      _1: "Unhandled error %s"
                    }), Printexc.to_string(err));
    }
  }
  var path = err._1;
  if (!path) {
    return Format.fprintf(ppf, /* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "Unmergeable objects",
                  _1: /* End_of_format */0
                },
                _1: "Unmergeable objects"
              });
  }
  var partial_arg = true;
  return Curry._2(Format.fprintf(ppf, /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Unmergeable objects, incompatibility at ",
                    _1: {
                      TAG: /* Alpha */15,
                      _0: /* End_of_format */0
                    }
                  },
                  _1: "Unmergeable objects, incompatibility at %a"
                }), (function (param, param$1) {
                return print_path_as_json_path(partial_arg, param, param$1);
              }), path);
}

function query(_path, _json) {
  while(true) {
    var json = _json;
    var path = _path;
    var match = Curry._1(Json_repr.Ezjsonm.view, json);
    if (!path) {
      return json;
    }
    var match$1 = path.hd;
    if (typeof match$1 === "string") {
      if (match$1 === "Star") {
        if (typeof match === "string") {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        var variant = match.NAME;
        var rempath = path.tl;
        if (variant === "A") {
          var match$2 = match.VAL;
          if (match$2) {
            try {
              return query(rempath, match$2.hd);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.RE_EXN_ID === "Not_found") {
                _json = Curry._1(Json_repr.Ezjsonm.repr, {
                      NAME: "A",
                      VAL: match$2.tl
                    });
                continue ;
              }
              throw exn;
            }
          } else {
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }
        } else if (variant === "O") {
          var match$3 = match.VAL;
          if (match$3) {
            try {
              return query(rempath, match$3.hd[1]);
            }
            catch (raw_exn$1){
              var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
              if (exn$1.RE_EXN_ID === "Not_found") {
                _json = Curry._1(Json_repr.Ezjsonm.repr, {
                      NAME: "O",
                      VAL: match$3.tl
                    });
                continue ;
              }
              throw exn$1;
            }
          } else {
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }
        } else {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
      } else {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
    } else {
      var variant$1 = match$1.NAME;
      if (variant$1 === "Index") {
        if (typeof match === "string") {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        if (match.NAME === "A") {
          var cells = match.VAL;
          var i = match$1.VAL;
          var i$1 = i < 0 ? List.length(cells) - i | 0 : i;
          _json = List.nth(cells, i$1);
          _path = path.tl;
          continue ;
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      if (variant$1 === "Field") {
        if (typeof match === "string") {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        if (match.NAME === "O") {
          var match$4 = match.VAL;
          if (match$4) {
            var match$5 = match$4.hd;
            if (match$1.VAL === match$5[0]) {
              _json = match$5[1];
              _path = path.tl;
              continue ;
            }
            _json = Curry._1(Json_repr.Ezjsonm.repr, {
                  NAME: "O",
                  VAL: match$4.tl
                });
            continue ;
          }
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
  };
}

function query_all(path, json) {
  var res = {
    contents: /* [] */0
  };
  var query = function (_path, _json) {
    while(true) {
      var json = _json;
      var path = _path;
      var match = Curry._1(Json_repr.Ezjsonm.view, json);
      if (!path) {
        res.contents = {
          hd: json,
          tl: res.contents
        };
        return ;
      }
      var match$1 = path.hd;
      if (typeof match$1 === "string") {
        if (match$1 !== "Star") {
          return ;
        }
        if (typeof match === "string") {
          return ;
        }
        var variant = match.NAME;
        var rempath = path.tl;
        if (variant === "A") {
          return List.iter((function(rempath){
                    return function (param) {
                      return query(rempath, param);
                    }
                    }(rempath)), match.VAL);
        } else if (variant === "O") {
          return List.iter((function(rempath){
                    return function (param) {
                      return query(rempath, param[1]);
                    }
                    }(rempath)), match.VAL);
        } else {
          return ;
        }
      }
      var variant$1 = match$1.NAME;
      if (variant$1 === "Index") {
        if (typeof match === "string") {
          return ;
        }
        if (match.NAME !== "A") {
          return ;
        }
        var cells = match.VAL;
        var i = match$1.VAL;
        var i$1 = i < 0 ? List.length(cells) - i | 0 : i;
        _json = List.nth(cells, i$1);
        _path = path.tl;
        continue ;
      }
      if (variant$1 !== "Field") {
        return ;
      }
      if (typeof match === "string") {
        return ;
      }
      if (match.NAME !== "O") {
        return ;
      }
      var match$2 = match.VAL;
      if (!match$2) {
        return ;
      }
      var match$3 = match$2.hd;
      if (match$1.VAL === match$3[0]) {
        _json = match$3[1];
        _path = path.tl;
        continue ;
      }
      _json = Curry._1(Json_repr.Ezjsonm.repr, {
            NAME: "O",
            VAL: match$2.tl
          });
      continue ;
    };
  };
  query(path, json);
  return res.contents;
}

function sort_fields(param) {
  return List.sort((function (param, param$1) {
                return Caml_primitive.caml_string_compare(param[0], param$1[0]);
              }), param);
}

function equals(l, r) {
  var canon = function (v) {
    var match = Curry._1(Json_repr.Ezjsonm.view, v);
    if (typeof match === "string") {
      return v;
    }
    var variant = match.NAME;
    if (variant === "A") {
      return Curry._1(Json_repr.Ezjsonm.repr, {
                  NAME: "A",
                  VAL: List.map(canon, match.VAL)
                });
    } else if (variant === "O") {
      return Curry._1(Json_repr.Ezjsonm.repr, {
                  NAME: "O",
                  VAL: sort_fields(List.map((function (param) {
                              return [
                                      param[0],
                                      canon(param[1])
                                    ];
                            }), match.VAL))
                });
    } else {
      return v;
    }
  };
  return Caml_obj.caml_equal(canon(l), canon(r));
}

function merge(l, r) {
  var merge$1 = function (path, l, r) {
    var match = Curry._1(Json_repr.Ezjsonm.view, l);
    var match$1 = Curry._1(Json_repr.Ezjsonm.view, r);
    if (typeof match === "string") {
      if (match === "Null") {
        return Curry._1(Json_repr.Ezjsonm.repr, match$1);
      }
      
    } else {
      var variant = match.NAME;
      if (variant === "A") {
        if (typeof match$1 !== "string" && match$1.NAME === "A") {
          return Curry._1(Json_repr.Ezjsonm.repr, {
                      NAME: "A",
                      VAL: merge_cells(path, 0, /* [] */0, match.VAL, match$1.VAL)
                    });
        }
        
      } else if (variant === "O" && typeof match$1 !== "string" && match$1.NAME === "O") {
        return Curry._1(Json_repr.Ezjsonm.repr, {
                    NAME: "O",
                    VAL: merge_fields(path, /* [] */0, sort_fields(Pervasives.$at(match.VAL, match$1.VAL)))
                  });
      }
      
    }
    if (match$1 === "Null") {
      return Curry._1(Json_repr.Ezjsonm.repr, match);
    }
    if (equals(l, r)) {
      return l;
    }
    throw {
          RE_EXN_ID: Cannot_merge,
          _1: List.rev(path),
          Error: new Error()
        };
  };
  var merge_cells = function (path, _i, _acc, _l, _r) {
    while(true) {
      var r = _r;
      var l = _l;
      var acc = _acc;
      var i = _i;
      if (!l) {
        return List.rev_append(acc, r);
      }
      if (!r) {
        return List.rev_append(acc, l);
      }
      var item = merge$1({
            hd: {
              NAME: "Index",
              VAL: i
            },
            tl: path
          }, l.hd, r.hd);
      _r = r.tl;
      _l = l.tl;
      _acc = {
        hd: item,
        tl: acc
      };
      _i = i + 1 | 0;
      continue ;
    };
  };
  var merge_fields = function (path, _acc, _last) {
    while(true) {
      var last = _last;
      var acc = _acc;
      if (!last) {
        return last;
      }
      var rrem = last.tl;
      if (!rrem) {
        return last;
      }
      var match = rrem.hd;
      var match$1 = last.hd;
      var lv = match$1[1];
      var lf = match$1[0];
      if (lf === match[0]) {
        var item = merge$1({
              hd: {
                NAME: "Field",
                VAL: lf
              },
              tl: path
            }, lv, match[1]);
        _last = rrem.tl;
        _acc = {
          hd: [
            lf,
            item
          ],
          tl: acc
        };
        continue ;
      }
      _last = rrem;
      _acc = {
        hd: [
          lf,
          lv
        ],
        tl: acc
      };
      continue ;
    };
  };
  return merge$1(/* [] */0, l, r);
}

function insert(mergeOpt, path, value, root) {
  var merge$1 = mergeOpt !== undefined ? mergeOpt : merge;
  var revpath = function (sub) {
    var _acc = /* [] */0;
    var _l = path;
    while(true) {
      var l = _l;
      var acc = _acc;
      if (l === sub) {
        return List.rev(acc);
      }
      if (l) {
        _l = l.tl;
        _acc = {
          hd: l.hd,
          tl: acc
        };
        continue ;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "json_query.re",
              267,
              29
            ],
            Error: new Error()
          };
    };
  };
  var merge$2 = function (path, l, r) {
    try {
      return Curry._2(merge$1, l, r);
    }
    catch (raw_sub){
      var sub = Caml_js_exceptions.internalToOCamlException(raw_sub);
      if (sub.RE_EXN_ID === Cannot_merge) {
        throw {
              RE_EXN_ID: Cannot_merge,
              _1: Pervasives.$at(revpath(path), sub._1),
              Error: new Error()
            };
      }
      throw sub;
    }
  };
  var nulls = function (_acc, _n, last) {
    while(true) {
      var n = _n;
      var acc = _acc;
      if (n <= 0) {
        return List.rev({
                    hd: last,
                    tl: acc
                  });
      }
      _n = n - 1 | 0;
      _acc = {
        hd: Curry._1(Json_repr.Ezjsonm.repr, "Null"),
        tl: acc
      };
      continue ;
    };
  };
  var insert$1 = function (root, path) {
    var root$1 = root !== undefined ? Curry._1(Json_repr.Ezjsonm.view, Caml_option.valFromOption(root)) : undefined;
    if (!path) {
      if (root$1 !== undefined) {
        return merge$2(path, value, Curry._1(Json_repr.Ezjsonm.repr, root$1));
      } else {
        return value;
      }
    }
    var match = path.hd;
    if (typeof match === "string") {
      if (match === "Star") {
        var rempath = path.tl;
        var exit = 0;
        if (root$1 !== undefined) {
          if (typeof root$1 === "string") {
            exit = 2;
          } else {
            var variant = root$1.NAME;
            if (variant === "A") {
              return Curry._1(Json_repr.Ezjsonm.repr, {
                          NAME: "A",
                          VAL: List.map((function (root) {
                                  return insert$1(Caml_option.some(root), rempath);
                                }), root$1.VAL)
                        });
            }
            if (variant === "O") {
              return Curry._1(Json_repr.Ezjsonm.repr, {
                          NAME: "O",
                          VAL: List.map((function (param) {
                                  return [
                                          param[0],
                                          insert$1(Caml_option.some(param[1]), rempath)
                                        ];
                                }), root$1.VAL)
                        });
            }
            exit = 2;
          }
        }
        if (exit === 2 && !rempath) {
          return merge$2(path, value, Curry._1(Json_repr.Ezjsonm.repr, root$1));
        }
        
      } else if (root$1 !== undefined && typeof root$1 !== "string" && root$1.NAME === "A") {
        return Curry._1(Json_repr.Ezjsonm.repr, {
                    NAME: "A",
                    VAL: List.rev_append(List.rev(root$1.VAL), {
                          hd: insert$1(undefined, path.tl),
                          tl: /* [] */0
                        })
                  });
      }
      
    } else {
      if (match.NAME === "Field") {
        var rempath$1 = path.tl;
        var n = match.VAL;
        if (root$1 === undefined) {
          return Curry._1(Json_repr.Ezjsonm.repr, {
                      NAME: "O",
                      VAL: {
                        hd: [
                          n,
                          insert$1(undefined, rempath$1)
                        ],
                        tl: /* [] */0
                      }
                    });
        }
        if (typeof root$1 === "string") {
          throw {
                RE_EXN_ID: Cannot_merge,
                _1: revpath(path),
                Error: new Error()
              };
        }
        if (root$1.NAME === "O") {
          return Curry._1(Json_repr.Ezjsonm.repr, {
                      NAME: "O",
                      VAL: insert_fields(/* [] */0, n, rempath$1, root$1.VAL)
                    });
        }
        throw {
              RE_EXN_ID: Cannot_merge,
              _1: revpath(path),
              Error: new Error()
            };
      }
      var i = match.VAL;
      var exit$1 = 0;
      if (root$1 !== undefined && typeof root$1 !== "string") {
        if (root$1.NAME === "A") {
          var cells = root$1.VAL;
          var i$1 = i < 0 ? List.length(cells) - i | 0 : i;
          if (i$1 < 0) {
            throw {
                  RE_EXN_ID: Cannot_merge,
                  _1: revpath(path),
                  Error: new Error()
                };
          }
          return Curry._1(Json_repr.Ezjsonm.repr, {
                      NAME: "A",
                      VAL: insert_cells(/* [] */0, i$1, path.tl, cells)
                    });
        }
        exit$1 = 2;
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2 && i !== 0) {
        if (root$1 !== undefined) {
          throw {
                RE_EXN_ID: Cannot_merge,
                _1: revpath(path),
                Error: new Error()
              };
        }
        if (i < 0) {
          throw {
                RE_EXN_ID: Cannot_merge,
                _1: revpath(path),
                Error: new Error()
              };
        }
        return Curry._1(Json_repr.Ezjsonm.repr, {
                    NAME: "A",
                    VAL: nulls(/* [] */0, Caml_primitive.caml_int_max(0, i - 1 | 0), insert$1(undefined, path.tl))
                  });
      }
      
    }
    if (root$1 !== undefined) {
      throw {
            RE_EXN_ID: Cannot_merge,
            _1: revpath(path),
            Error: new Error()
          };
    }
    return Curry._1(Json_repr.Ezjsonm.repr, {
                NAME: "A",
                VAL: {
                  hd: insert$1(undefined, path.tl),
                  tl: /* [] */0
                }
              });
  };
  var insert_fields = function (_acc, n, rempath, _fields) {
    while(true) {
      var fields = _fields;
      var acc = _acc;
      if (!fields) {
        return List.rev({
                    hd: [
                      n,
                      insert$1(undefined, rempath)
                    ],
                    tl: acc
                  });
      }
      var rem = fields.tl;
      var other = fields.hd;
      if (n === other[0]) {
        return List.rev_append({
                    hd: [
                      n,
                      insert$1(Caml_option.some(other[1]), rempath)
                    ],
                    tl: acc
                  }, rem);
      }
      _fields = rem;
      _acc = {
        hd: other,
        tl: acc
      };
      continue ;
    };
  };
  var insert_cells = function (_acc, _n, rempath, _cells) {
    while(true) {
      var cells = _cells;
      var n = _n;
      var acc = _acc;
      if (!cells) {
        return nulls(acc, n, insert$1(undefined, rempath));
      }
      var rem = cells.tl;
      var root = cells.hd;
      if (n === 0) {
        return List.rev_append({
                    hd: insert$1(Caml_option.some(root), rempath),
                    tl: acc
                  }, rem);
      }
      _cells = rem;
      _n = n - 1 | 0;
      _acc = {
        hd: root,
        tl: acc
      };
      continue ;
    };
  };
  return insert$1(Caml_option.some(root), path);
}

function replace(path, value, root) {
  return insert((function (value, _prev) {
                return value;
              }), path, value, root);
}

function insert$1(path, value, root) {
  return insert(undefined, path, value, root);
}

function Make(funarg) {
  var query = function (_path, _json) {
    while(true) {
      var json = _json;
      var path = _path;
      var match = Curry._1(funarg.view, json);
      if (!path) {
        return json;
      }
      var match$1 = path.hd;
      if (typeof match$1 === "string") {
        if (match$1 === "Star") {
          if (typeof match === "string") {
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }
          var variant = match.NAME;
          var rempath = path.tl;
          if (variant === "A") {
            var match$2 = match.VAL;
            if (match$2) {
              try {
                return query(rempath, match$2.hd);
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.RE_EXN_ID === "Not_found") {
                  _json = Curry._1(funarg.repr, {
                        NAME: "A",
                        VAL: match$2.tl
                      });
                  continue ;
                }
                throw exn;
              }
            } else {
              throw {
                    RE_EXN_ID: "Not_found",
                    Error: new Error()
                  };
            }
          } else if (variant === "O") {
            var match$3 = match.VAL;
            if (match$3) {
              try {
                return query(rempath, match$3.hd[1]);
              }
              catch (raw_exn$1){
                var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                if (exn$1.RE_EXN_ID === "Not_found") {
                  _json = Curry._1(funarg.repr, {
                        NAME: "O",
                        VAL: match$3.tl
                      });
                  continue ;
                }
                throw exn$1;
              }
            } else {
              throw {
                    RE_EXN_ID: "Not_found",
                    Error: new Error()
                  };
            }
          } else {
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }
        } else {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
      } else {
        var variant$1 = match$1.NAME;
        if (variant$1 === "Index") {
          if (typeof match === "string") {
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }
          if (match.NAME === "A") {
            var cells = match.VAL;
            var i = match$1.VAL;
            var i$1 = i < 0 ? List.length(cells) - i | 0 : i;
            _json = List.nth(cells, i$1);
            _path = path.tl;
            continue ;
          }
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        if (variant$1 === "Field") {
          if (typeof match === "string") {
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }
          if (match.NAME === "O") {
            var match$4 = match.VAL;
            if (match$4) {
              var match$5 = match$4.hd;
              if (match$1.VAL === match$5[0]) {
                _json = match$5[1];
                _path = path.tl;
                continue ;
              }
              _json = Curry._1(funarg.repr, {
                    NAME: "O",
                    VAL: match$4.tl
                  });
              continue ;
            }
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
          }
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
    };
  };
  var query_all = function (path, json) {
    var res = {
      contents: /* [] */0
    };
    var query = function (_path, _json) {
      while(true) {
        var json = _json;
        var path = _path;
        var match = Curry._1(funarg.view, json);
        if (!path) {
          res.contents = {
            hd: json,
            tl: res.contents
          };
          return ;
        }
        var match$1 = path.hd;
        if (typeof match$1 === "string") {
          if (match$1 !== "Star") {
            return ;
          }
          if (typeof match === "string") {
            return ;
          }
          var variant = match.NAME;
          var rempath = path.tl;
          if (variant === "A") {
            return List.iter((function(rempath){
                      return function (param) {
                        return query(rempath, param);
                      }
                      }(rempath)), match.VAL);
          } else if (variant === "O") {
            return List.iter((function(rempath){
                      return function (param) {
                        return query(rempath, param[1]);
                      }
                      }(rempath)), match.VAL);
          } else {
            return ;
          }
        }
        var variant$1 = match$1.NAME;
        if (variant$1 === "Index") {
          if (typeof match === "string") {
            return ;
          }
          if (match.NAME !== "A") {
            return ;
          }
          var cells = match.VAL;
          var i = match$1.VAL;
          var i$1 = i < 0 ? List.length(cells) - i | 0 : i;
          _json = List.nth(cells, i$1);
          _path = path.tl;
          continue ;
        }
        if (variant$1 !== "Field") {
          return ;
        }
        if (typeof match === "string") {
          return ;
        }
        if (match.NAME !== "O") {
          return ;
        }
        var match$2 = match.VAL;
        if (!match$2) {
          return ;
        }
        var match$3 = match$2.hd;
        if (match$1.VAL === match$3[0]) {
          _json = match$3[1];
          _path = path.tl;
          continue ;
        }
        _json = Curry._1(funarg.repr, {
              NAME: "O",
              VAL: match$2.tl
            });
        continue ;
      };
    };
    query(path, json);
    return res.contents;
  };
  var sort_fields = function (param) {
    return List.sort((function (param, param$1) {
                  return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                }), param);
  };
  var equals = function (l, r) {
    var canon = function (v) {
      var match = Curry._1(funarg.view, v);
      if (typeof match === "string") {
        return v;
      }
      var variant = match.NAME;
      if (variant === "A") {
        return Curry._1(funarg.repr, {
                    NAME: "A",
                    VAL: List.map(canon, match.VAL)
                  });
      } else if (variant === "O") {
        return Curry._1(funarg.repr, {
                    NAME: "O",
                    VAL: sort_fields(List.map((function (param) {
                                return [
                                        param[0],
                                        canon(param[1])
                                      ];
                              }), match.VAL))
                  });
      } else {
        return v;
      }
    };
    return Caml_obj.caml_equal(canon(l), canon(r));
  };
  var merge = function (l, r) {
    var merge$1 = function (path, l, r) {
      var match = Curry._1(funarg.view, l);
      var match$1 = Curry._1(funarg.view, r);
      if (typeof match === "string") {
        if (match === "Null") {
          return Curry._1(funarg.repr, match$1);
        }
        
      } else {
        var variant = match.NAME;
        if (variant === "A") {
          if (typeof match$1 !== "string" && match$1.NAME === "A") {
            return Curry._1(funarg.repr, {
                        NAME: "A",
                        VAL: merge_cells(path, 0, /* [] */0, match.VAL, match$1.VAL)
                      });
          }
          
        } else if (variant === "O" && typeof match$1 !== "string" && match$1.NAME === "O") {
          return Curry._1(funarg.repr, {
                      NAME: "O",
                      VAL: merge_fields(path, /* [] */0, sort_fields(Pervasives.$at(match.VAL, match$1.VAL)))
                    });
        }
        
      }
      if (match$1 === "Null") {
        return Curry._1(funarg.repr, match);
      }
      if (equals(l, r)) {
        return l;
      }
      throw {
            RE_EXN_ID: Cannot_merge,
            _1: List.rev(path),
            Error: new Error()
          };
    };
    var merge_cells = function (path, _i, _acc, _l, _r) {
      while(true) {
        var r = _r;
        var l = _l;
        var acc = _acc;
        var i = _i;
        if (!l) {
          return List.rev_append(acc, r);
        }
        if (!r) {
          return List.rev_append(acc, l);
        }
        var item = merge$1({
              hd: {
                NAME: "Index",
                VAL: i
              },
              tl: path
            }, l.hd, r.hd);
        _r = r.tl;
        _l = l.tl;
        _acc = {
          hd: item,
          tl: acc
        };
        _i = i + 1 | 0;
        continue ;
      };
    };
    var merge_fields = function (path, _acc, _last) {
      while(true) {
        var last = _last;
        var acc = _acc;
        if (!last) {
          return last;
        }
        var rrem = last.tl;
        if (!rrem) {
          return last;
        }
        var match = rrem.hd;
        var match$1 = last.hd;
        var lv = match$1[1];
        var lf = match$1[0];
        if (lf === match[0]) {
          var item = merge$1({
                hd: {
                  NAME: "Field",
                  VAL: lf
                },
                tl: path
              }, lv, match[1]);
          _last = rrem.tl;
          _acc = {
            hd: [
              lf,
              item
            ],
            tl: acc
          };
          continue ;
        }
        _last = rrem;
        _acc = {
          hd: [
            lf,
            lv
          ],
          tl: acc
        };
        continue ;
      };
    };
    return merge$1(/* [] */0, l, r);
  };
  var insert = function (mergeOpt, path, value, root) {
    var merge$1 = mergeOpt !== undefined ? mergeOpt : merge;
    var revpath = function (sub) {
      var _acc = /* [] */0;
      var _l = path;
      while(true) {
        var l = _l;
        var acc = _acc;
        if (l === sub) {
          return List.rev(acc);
        }
        if (l) {
          _l = l.tl;
          _acc = {
            hd: l.hd,
            tl: acc
          };
          continue ;
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "json_query.re",
                267,
                29
              ],
              Error: new Error()
            };
      };
    };
    var merge$2 = function (path, l, r) {
      try {
        return Curry._2(merge$1, l, r);
      }
      catch (raw_sub){
        var sub = Caml_js_exceptions.internalToOCamlException(raw_sub);
        if (sub.RE_EXN_ID === Cannot_merge) {
          throw {
                RE_EXN_ID: Cannot_merge,
                _1: Pervasives.$at(revpath(path), sub._1),
                Error: new Error()
              };
        }
        throw sub;
      }
    };
    var nulls = function (_acc, _n, last) {
      while(true) {
        var n = _n;
        var acc = _acc;
        if (n <= 0) {
          return List.rev({
                      hd: last,
                      tl: acc
                    });
        }
        _n = n - 1 | 0;
        _acc = {
          hd: Curry._1(funarg.repr, "Null"),
          tl: acc
        };
        continue ;
      };
    };
    var insert$1 = function (root, path) {
      var root$1 = root !== undefined ? Curry._1(funarg.view, Caml_option.valFromOption(root)) : undefined;
      if (!path) {
        if (root$1 !== undefined) {
          return merge$2(path, value, Curry._1(funarg.repr, root$1));
        } else {
          return value;
        }
      }
      var match = path.hd;
      if (typeof match === "string") {
        if (match === "Star") {
          var rempath = path.tl;
          var exit = 0;
          if (root$1 !== undefined) {
            if (typeof root$1 === "string") {
              exit = 2;
            } else {
              var variant = root$1.NAME;
              if (variant === "A") {
                return Curry._1(funarg.repr, {
                            NAME: "A",
                            VAL: List.map((function (root) {
                                    return insert$1(Caml_option.some(root), rempath);
                                  }), root$1.VAL)
                          });
              }
              if (variant === "O") {
                return Curry._1(funarg.repr, {
                            NAME: "O",
                            VAL: List.map((function (param) {
                                    return [
                                            param[0],
                                            insert$1(Caml_option.some(param[1]), rempath)
                                          ];
                                  }), root$1.VAL)
                          });
              }
              exit = 2;
            }
          }
          if (exit === 2 && !rempath) {
            return merge$2(path, value, Curry._1(funarg.repr, root$1));
          }
          
        } else if (root$1 !== undefined && typeof root$1 !== "string" && root$1.NAME === "A") {
          return Curry._1(funarg.repr, {
                      NAME: "A",
                      VAL: List.rev_append(List.rev(root$1.VAL), {
                            hd: insert$1(undefined, path.tl),
                            tl: /* [] */0
                          })
                    });
        }
        
      } else {
        if (match.NAME === "Field") {
          var rempath$1 = path.tl;
          var n = match.VAL;
          if (root$1 === undefined) {
            return Curry._1(funarg.repr, {
                        NAME: "O",
                        VAL: {
                          hd: [
                            n,
                            insert$1(undefined, rempath$1)
                          ],
                          tl: /* [] */0
                        }
                      });
          }
          if (typeof root$1 === "string") {
            throw {
                  RE_EXN_ID: Cannot_merge,
                  _1: revpath(path),
                  Error: new Error()
                };
          }
          if (root$1.NAME === "O") {
            return Curry._1(funarg.repr, {
                        NAME: "O",
                        VAL: insert_fields(/* [] */0, n, rempath$1, root$1.VAL)
                      });
          }
          throw {
                RE_EXN_ID: Cannot_merge,
                _1: revpath(path),
                Error: new Error()
              };
        }
        var i = match.VAL;
        var exit$1 = 0;
        if (root$1 !== undefined && typeof root$1 !== "string") {
          if (root$1.NAME === "A") {
            var cells = root$1.VAL;
            var i$1 = i < 0 ? List.length(cells) - i | 0 : i;
            if (i$1 < 0) {
              throw {
                    RE_EXN_ID: Cannot_merge,
                    _1: revpath(path),
                    Error: new Error()
                  };
            }
            return Curry._1(funarg.repr, {
                        NAME: "A",
                        VAL: insert_cells(/* [] */0, i$1, path.tl, cells)
                      });
          }
          exit$1 = 2;
        } else {
          exit$1 = 2;
        }
        if (exit$1 === 2 && i !== 0) {
          if (root$1 !== undefined) {
            throw {
                  RE_EXN_ID: Cannot_merge,
                  _1: revpath(path),
                  Error: new Error()
                };
          }
          if (i < 0) {
            throw {
                  RE_EXN_ID: Cannot_merge,
                  _1: revpath(path),
                  Error: new Error()
                };
          }
          return Curry._1(funarg.repr, {
                      NAME: "A",
                      VAL: nulls(/* [] */0, Caml_primitive.caml_int_max(0, i - 1 | 0), insert$1(undefined, path.tl))
                    });
        }
        
      }
      if (root$1 !== undefined) {
        throw {
              RE_EXN_ID: Cannot_merge,
              _1: revpath(path),
              Error: new Error()
            };
      }
      return Curry._1(funarg.repr, {
                  NAME: "A",
                  VAL: {
                    hd: insert$1(undefined, path.tl),
                    tl: /* [] */0
                  }
                });
    };
    var insert_fields = function (_acc, n, rempath, _fields) {
      while(true) {
        var fields = _fields;
        var acc = _acc;
        if (!fields) {
          return List.rev({
                      hd: [
                        n,
                        insert$1(undefined, rempath)
                      ],
                      tl: acc
                    });
        }
        var rem = fields.tl;
        var other = fields.hd;
        if (n === other[0]) {
          return List.rev_append({
                      hd: [
                        n,
                        insert$1(Caml_option.some(other[1]), rempath)
                      ],
                      tl: acc
                    }, rem);
        }
        _fields = rem;
        _acc = {
          hd: other,
          tl: acc
        };
        continue ;
      };
    };
    var insert_cells = function (_acc, _n, rempath, _cells) {
      while(true) {
        var cells = _cells;
        var n = _n;
        var acc = _acc;
        if (!cells) {
          return nulls(acc, n, insert$1(undefined, rempath));
        }
        var rem = cells.tl;
        var root = cells.hd;
        if (n === 0) {
          return List.rev_append({
                      hd: insert$1(Caml_option.some(root), rempath),
                      tl: acc
                    }, rem);
        }
        _cells = rem;
        _n = n - 1 | 0;
        _acc = {
          hd: root,
          tl: acc
        };
        continue ;
      };
    };
    return insert$1(Caml_option.some(root), path);
  };
  var replace = function (path, value, root) {
    return insert((function (value, _prev) {
                  return value;
                }), path, value, root);
  };
  var insert$1 = function (path, value, root) {
    return insert(undefined, path, value, root);
  };
  return {
          query: query,
          query_all: query_all,
          insert: insert$1,
          replace: replace,
          merge: merge
        };
}

exports.print_path_as_json_pointer = print_path_as_json_pointer;
exports.print_path_as_json_path = print_path_as_json_path;
exports.json_pointer_of_path = json_pointer_of_path;
exports.path_of_json_pointer = path_of_json_pointer;
exports.query = query;
exports.query_all = query_all;
exports.insert = insert$1;
exports.replace = replace;
exports.merge = merge;
exports.Cannot_merge = Cannot_merge;
exports.Illegal_pointer_notation = Illegal_pointer_notation;
exports.Unsupported_path_item = Unsupported_path_item;
exports.print_error = print_error;
exports.Make = Make;
/* Format Not a pure module */
